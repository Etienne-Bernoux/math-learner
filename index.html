<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="description" content="Apprends les maths en t'amusant ! Mode enfant avec puzzles √† d√©bloquer, et calcul mental avanc√© pour les grands.">
  <meta name="keywords" content="calcul mental, maths, enfant, apprentissage, tables multiplication, addition, soustraction">
  <meta name="author" content="MathQuiz">
  <meta name="theme-color" content="#4c1d95">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="MathQuiz">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üßÆ</text></svg>">
  <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%234c1d95' width='100' height='100' rx='20'/><text y='.9em' x='5' font-size='80'>üßÆ</text></svg>">
  <title>MathQuiz - Apprends √† compter en t'amusant !</title>
  <!-- PWA Manifest -->
  <link rel="manifest" href="data:application/json,%7B%22name%22%3A%22MathQuiz%22%2C%22short_name%22%3A%22MathQuiz%22%2C%22start_url%22%3A%22.%22%2C%22display%22%3A%22standalone%22%2C%22background_color%22%3A%22%234c1d95%22%2C%22theme_color%22%3A%22%234c1d95%22%7D">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    * { -webkit-tap-highlight-color: transparent; }
    input::-webkit-outer-spin-button,
    input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    input[type=number] { -moz-appearance: textfield; }

    /* Animations */
    @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
    @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
    @keyframes pop { 0% { transform: scale(0.8); opacity: 0; } 50% { transform: scale(1.1); } 100% { transform: scale(1); opacity: 1; } }
    @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
    @keyframes shine { 0% { background-position: -100% 0; } 100% { background-position: 200% 0; } }
    @keyframes confetti { 0% { transform: translateY(0) rotate(0); opacity: 1; } 100% { transform: translateY(-100px) rotate(720deg); opacity: 0; } }
    @keyframes puzzleReveal { 0% { transform: scale(0) rotate(-180deg); opacity: 0; } 100% { transform: scale(1) rotate(0); opacity: 1; } }
    @keyframes celebrate { 0% { transform: scale(1); } 25% { transform: scale(1.2) rotate(-5deg); } 50% { transform: scale(1.3); } 75% { transform: scale(1.2) rotate(5deg); } 100% { transform: scale(1); } }
    @keyframes bounce-in { 0% { transform: scale(0); } 50% { transform: scale(1.2); } 100% { transform: scale(1); } }
    @keyframes star-pop { 0% { transform: scale(0) rotate(-180deg); } 60% { transform: scale(1.3) rotate(10deg); } 100% { transform: scale(1) rotate(0); } }

    .animate-fade-in { animation: fadeIn 0.3s ease-out; }
    .animate-bounce-in { animation: bounce-in 0.4s ease-out; }
    .animate-star-pop { animation: star-pop 0.5s ease-out forwards; }
    .animate-pulse-slow { animation: pulse 2s ease-in-out infinite; }
    .animate-shake { animation: shake 0.3s ease-in-out; }
    .animate-pop { animation: pop 0.4s ease-out; }
    .animate-float { animation: float 3s ease-in-out infinite; }
    .animate-puzzle-reveal { animation: puzzleReveal 0.6s ease-out forwards; }
    .animate-celebrate { animation: celebrate 1s ease-in-out; }

    .shine-effect {
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
      background-size: 200% 100%;
      animation: shine 2s infinite;
    }

    /* Confetti */
    .confetti-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      overflow: hidden;
      z-index: 100;
    }
    .confetti {
      position: absolute;
      width: 10px;
      height: 10px;
      animation: confetti-fall 3s ease-out forwards;
    }
    @keyframes confetti-fall {
      0% { transform: translateY(-10px) rotate(0deg); opacity: 1; }
      100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
    }

    /* Smooth scrollbar */
    ::-webkit-scrollbar { width: 6px; height: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.3); }

    /* Selection color */
    ::selection { background: rgba(168, 85, 247, 0.4); }

    /* Button hover effects */
    .btn-glow:hover {
      box-shadow: 0 0 20px rgba(168, 85, 247, 0.5), 0 0 40px rgba(168, 85, 247, 0.3);
    }
    .btn-glow-green:hover {
      box-shadow: 0 0 20px rgba(34, 197, 94, 0.5), 0 0 40px rgba(34, 197, 94, 0.3);
    }

    /* Smooth transitions globales */
    button, a { transition: all 0.2s ease-out; }

    /* Active state */
    button:active { transform: scale(0.97); }

    /* Focus ring */
    button:focus-visible {
      outline: 2px solid rgba(168, 85, 247, 0.8);
      outline-offset: 2px;
    }

    /* Card hover */
    .card-hover { transition: transform 0.2s, box-shadow 0.2s; }
    .card-hover:hover { transform: translateY(-2px); box-shadow: 0 10px 30px rgba(0,0,0,0.15); }

    /* Gradient text */
    .text-gradient {
      background: linear-gradient(135deg, #8b5cf6, #ec4899);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    /* Loading dots */
    @keyframes dots { 0%, 20% { opacity: 0; } 50% { opacity: 1; } 100% { opacity: 0; } }
    .loading-dot { animation: dots 1.4s infinite; }
    .loading-dot:nth-child(2) { animation-delay: 0.2s; }
    .loading-dot:nth-child(3) { animation-delay: 0.4s; }

    /* Success checkmark */
    @keyframes checkmark { 0% { stroke-dashoffset: 50; } 100% { stroke-dashoffset: 0; } }
    .checkmark { stroke-dasharray: 50; stroke-dashoffset: 50; animation: checkmark 0.5s ease-out forwards; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const QUESTIONS_COUNT = 10;

    // ========== STORAGE ==========
    const STORAGE_KEY = 'mathquiz_stats';
    const PUZZLE_KEY = 'mathquiz_puzzles';

    const defaultStats = {
      totalScore: 0,
      gamesPlayed: 0,
      perfectGames: 0,
      bestStreak: 0,
      totalCorrect: 0,
      totalQuestions: 0,
      expertPerfects: 0,
      fastAnswers: 0,
      achievements: [],
    };

    const defaultPuzzles = {
      currentPuzzle: 0,
      puzzles: [
        { id: 0, pieces: Array(9).fill(false), completed: false, lives: 0 },
        { id: 1, pieces: Array(9).fill(false), completed: false, lives: 0 },
        { id: 2, pieces: Array(9).fill(false), completed: false, lives: 0 },
        { id: 3, pieces: Array(9).fill(false), completed: false, lives: 0 },
        { id: 4, pieces: Array(9).fill(false), completed: false, lives: 0 },
        { id: 5, pieces: Array(9).fill(false), completed: false, lives: 0 },
        { id: 6, pieces: Array(9).fill(false), completed: false, lives: 0 },
        { id: 7, pieces: Array(9).fill(false), completed: false, lives: 0 },
        { id: 8, pieces: Array(9).fill(false), completed: false, lives: 0 },
        { id: 9, pieces: Array(9).fill(false), completed: false, lives: 0 },
      ],
    };

    function loadStats() {
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        return saved ? { ...defaultStats, ...JSON.parse(saved) } : defaultStats;
      } catch {
        return defaultStats;
      }
    }

    function saveStats(stats) {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(stats));
      } catch {}
    }

    function loadPuzzles() {
      try {
        const saved = localStorage.getItem(PUZZLE_KEY);
        if (!saved) return defaultPuzzles;
        const parsed = JSON.parse(saved);
        // Merge puzzles array to ensure all 10 entries exist
        const mergedPuzzles = defaultPuzzles.puzzles.map((def, idx) =>
          parsed.puzzles && parsed.puzzles[idx] ? { ...def, ...parsed.puzzles[idx] } : def
        );
        return { ...defaultPuzzles, ...parsed, puzzles: mergedPuzzles };
      } catch {
        return defaultPuzzles;
      }
    }

    function savePuzzles(puzzles) {
      try {
        localStorage.setItem(PUZZLE_KEY, JSON.stringify(puzzles));
      } catch {}
    }

    // ========== PUZZLES CONFIG ==========
    // SVG images for puzzles (simple illustrations)
    const PUZZLE_IMAGES = {
      knight: `<svg viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg">
        <rect fill="#fef3c7" width="300" height="300"/>
        <circle cx="150" cy="80" r="45" fill="#6b7280"/>
        <path d="M120 60 L150 20 L180 60" fill="#6b7280"/>
        <rect x="105" y="125" width="90" height="100" rx="10" fill="#3b82f6"/>
        <rect x="60" y="130" width="45" height="20" rx="5" fill="#3b82f6"/>
        <rect x="195" y="130" width="45" height="20" rx="5" fill="#3b82f6"/>
        <polygon points="230,100 280,150 230,200" fill="#d97706"/>
        <rect x="240" y="140" width="50" height="20" fill="#92400e"/>
        <rect x="120" y="225" width="25" height="60" fill="#1f2937"/>
        <rect x="155" y="225" width="25" height="60" fill="#1f2937"/>
        <rect x="125" y="165" width="50" height="8" fill="#fbbf24"/>
        <circle cx="150" cy="80" r="15" fill="#e5e7eb"/>
        <rect x="135" y="70" width="30" height="5" fill="#1f2937"/>
      </svg>`,
      pirate: `<svg viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg">
        <rect fill="#bae6fd" width="300" height="300"/>
        <rect y="200" width="300" height="100" fill="#0ea5e9"/>
        <path d="M50,220 Q150,180 250,220 L250,280 L50,280 Z" fill="#92400e"/>
        <rect x="140" y="100" width="20" height="120" fill="#78350f"/>
        <polygon points="160,100 160,180 260,140" fill="#f5f5f4"/>
        <circle cx="210" cy="140" r="20" fill="#1f2937"/>
        <path d="M200,130 L220,150 M200,150 L220,130" stroke="white" stroke-width="4"/>
        <circle cx="100" cy="250" r="15" fill="#1f2937"/>
        <circle cx="200" cy="250" r="15" fill="#1f2937"/>
        <path d="M30,210 Q60,190 90,210" stroke="#78350f" stroke-width="8" fill="none"/>
        <path d="M210,210 Q240,190 270,210" stroke="#78350f" stroke-width="8" fill="none"/>
        <circle cx="150" cy="60" r="30" fill="#fbbf24"/>
        <path d="M130,60 L170,60 M150,40 L150,80 M135,45 L165,75 M165,45 L135,75" stroke="#f59e0b" stroke-width="3"/>
      </svg>`,
      dragon: `<svg viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg">
        <rect fill="#fecaca" width="300" height="300"/>
        <ellipse cx="150" cy="200" rx="80" ry="50" fill="#16a34a"/>
        <ellipse cx="150" cy="160" rx="60" ry="40" fill="#22c55e"/>
        <circle cx="150" cy="100" r="50" fill="#22c55e"/>
        <polygon points="120,60 150,20 180,60" fill="#22c55e"/>
        <polygon points="100,70 70,40 110,80" fill="#22c55e"/>
        <polygon points="200,70 230,40 190,80" fill="#22c55e"/>
        <circle cx="130" cy="90" r="12" fill="#fef3c7"/>
        <circle cx="170" cy="90" r="12" fill="#fef3c7"/>
        <circle cx="130" cy="90" r="6" fill="#1f2937"/>
        <circle cx="170" cy="90" r="6" fill="#1f2937"/>
        <ellipse cx="150" cy="120" rx="8" ry="5" fill="#1f2937"/>
        <path d="M60,180 Q30,150 50,120" stroke="#22c55e" stroke-width="20" fill="none"/>
        <path d="M240,180 Q270,150 250,120" stroke="#22c55e" stroke-width="20" fill="none"/>
        <path d="M150,250 Q150,280 180,290" stroke="#22c55e" stroke-width="15" fill="none"/>
        <polygon points="180,285 200,300 175,300" fill="#22c55e"/>
        <ellipse cx="80" cy="130" rx="30" ry="20" fill="#22c55e"/>
        <ellipse cx="220" cy="130" rx="30" ry="20" fill="#22c55e"/>
        <path d="M120,135 L140,150 L120,145 L135,160" fill="#ef4444"/>
        <path d="M180,135 L160,150 L180,145 L165,160" fill="#ef4444"/>
      </svg>`,
      unicorn: `<svg viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg">
        <rect fill="#fae8ff" width="300" height="300"/>
        <ellipse cx="150" cy="200" rx="70" ry="45" fill="white" stroke="#e879f9" stroke-width="2"/>
        <ellipse cx="100" cy="230" rx="15" ry="35" fill="white" stroke="#e879f9" stroke-width="2"/>
        <ellipse cx="130" cy="235" rx="15" ry="35" fill="white" stroke="#e879f9" stroke-width="2"/>
        <ellipse cx="170" cy="235" rx="15" ry="35" fill="white" stroke="#e879f9" stroke-width="2"/>
        <ellipse cx="200" cy="230" rx="15" ry="35" fill="white" stroke="#e879f9" stroke-width="2"/>
        <ellipse cx="80" cy="150" rx="35" ry="50" fill="white" stroke="#e879f9" stroke-width="2"/>
        <polygon points="80,100 90,40 100,100" fill="#fbbf24"/>
        <circle cx="65" cy="140" r="8" fill="#1f2937"/>
        <circle cx="63" cy="138" r="3" fill="white"/>
        <path d="M50,160 Q60,170 75,165" stroke="#f472b6" stroke-width="2" fill="none"/>
        <path d="M60,110 Q30,100 20,130 Q10,160 40,150" fill="#f9a8d4"/>
        <path d="M60,115 Q35,110 30,135 Q25,155 45,148" fill="#f472b6"/>
        <path d="M60,120 Q45,118 42,135 Q40,148 52,145" fill="#c084fc"/>
        <path d="M200,180 Q240,170 260,190 Q280,210 250,220" fill="#f9a8d4"/>
        <path d="M200,185 Q235,178 250,195 Q265,210 245,218" fill="#f472b6"/>
        <path d="M200,190 Q225,185 238,198 Q250,210 235,215" fill="#c084fc"/>
        <ellipse cx="150" cy="165" rx="25" ry="8" fill="#fdf4ff"/>
        <circle cx="220" cy="120" r="15" fill="#fef08a"/>
        <polygon points="220,100 225,110 235,110 227,118 230,128 220,122 210,128 213,118 205,110 215,110" fill="#fde047"/>
      </svg>`,
      robot: `<svg viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg">
        <rect fill="#e0f2fe" width="300" height="300"/>
        <rect x="100" y="80" width="100" height="90" rx="15" fill="#64748b"/>
        <rect x="90" y="90" width="120" height="70" rx="10" fill="#94a3b8"/>
        <circle cx="125" cy="125" r="18" fill="#1e293b"/>
        <circle cx="175" cy="125" r="18" fill="#1e293b"/>
        <circle cx="125" cy="125" r="10" fill="#22d3ee"/>
        <circle cx="175" cy="125" r="10" fill="#22d3ee"/>
        <rect x="135" y="145" width="30" height="8" rx="2" fill="#1e293b"/>
        <rect x="140" y="40" width="20" height="40" fill="#94a3b8"/>
        <circle cx="150" cy="35" r="12" fill="#f87171"/>
        <rect x="110" y="170" width="80" height="70" rx="10" fill="#64748b"/>
        <rect x="120" y="185" width="60" height="15" rx="3" fill="#1e293b"/>
        <rect x="130" y="210" width="15" height="20" fill="#22d3ee"/>
        <rect x="155" y="210" width="15" height="20" fill="#22d3ee"/>
        <rect x="60" y="180" width="50" height="20" rx="5" fill="#94a3b8"/>
        <rect x="190" y="180" width="50" height="20" rx="5" fill="#94a3b8"/>
        <rect x="120" y="240" width="25" height="40" fill="#64748b"/>
        <rect x="155" y="240" width="25" height="40" fill="#64748b"/>
      </svg>`,
      rocket: `<svg viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg">
        <rect fill="#1e1b4b" width="300" height="300"/>
        <circle cx="50" cy="80" r="3" fill="white"/><circle cx="250" cy="50" r="2" fill="white"/>
        <circle cx="200" cy="100" r="2" fill="white"/><circle cx="80" cy="200" r="3" fill="white"/>
        <circle cx="230" cy="180" r="2" fill="white"/><circle cx="40" cy="250" r="2" fill="white"/>
        <ellipse cx="150" cy="150" rx="35" ry="80" fill="#e2e8f0"/>
        <ellipse cx="150" cy="150" rx="25" ry="70" fill="#f1f5f9"/>
        <ellipse cx="150" cy="100" rx="25" ry="30" fill="#ef4444"/>
        <circle cx="150" cy="140" r="20" fill="#0ea5e9"/>
        <circle cx="150" cy="140" r="12" fill="#7dd3fc"/>
        <polygon points="105,180 85,220 115,190" fill="#64748b"/>
        <polygon points="195,180 215,220 185,190" fill="#64748b"/>
        <polygon points="130,230 150,280 170,230" fill="#f97316"/>
        <polygon points="140,230 150,260 160,230" fill="#fbbf24"/>
        <polygon points="120,225 135,250 145,225" fill="#f97316"/>
        <polygon points="155,225 165,250 180,225" fill="#f97316"/>
      </svg>`,
      cat: `<svg viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg">
        <rect fill="#fef9c3" width="300" height="300"/>
        <ellipse cx="150" cy="200" rx="80" ry="60" fill="#f97316"/>
        <circle cx="150" cy="130" r="70" fill="#f97316"/>
        <polygon points="85,80 70,20 110,70" fill="#f97316"/>
        <polygon points="215,80 230,20 190,70" fill="#f97316"/>
        <polygon points="90,75 75,30 105,68" fill="#fda4af"/>
        <polygon points="210,75 225,30 195,68" fill="#fda4af"/>
        <ellipse cx="120" cy="120" rx="18" ry="22" fill="white"/>
        <ellipse cx="180" cy="120" rx="18" ry="22" fill="white"/>
        <ellipse cx="123" cy="125" rx="10" ry="14" fill="#1e293b"/>
        <ellipse cx="183" cy="125" rx="10" ry="14" fill="#1e293b"/>
        <ellipse cx="150" cy="155" rx="12" ry="8" fill="#fda4af"/>
        <path d="M150,163 L145,175 L155,175 Z" fill="#fda4af"/>
        <path d="M130,165 Q150,180 170,165" stroke="#1e293b" stroke-width="3" fill="none"/>
        <line x1="90" y1="145" x2="50" y2="140" stroke="#1e293b" stroke-width="2"/>
        <line x1="90" y1="155" x2="50" y2="160" stroke="#1e293b" stroke-width="2"/>
        <line x1="210" y1="145" x2="250" y2="140" stroke="#1e293b" stroke-width="2"/>
        <line x1="210" y1="155" x2="250" y2="160" stroke="#1e293b" stroke-width="2"/>
        <path d="M220,220 Q260,200 250,260 Q240,290 220,270" fill="#f97316"/>
      </svg>`,
      owl: `<svg viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg">
        <rect fill="#1e3a5f" width="300" height="300"/>
        <circle cx="80" cy="50" r="8" fill="#fef08a"/>
        <circle cx="220" cy="80" r="5" fill="#fef08a"/>
        <ellipse cx="150" cy="180" rx="70" ry="90" fill="#78350f"/>
        <ellipse cx="150" cy="200" rx="50" ry="60" fill="#fef3c7"/>
        <circle cx="115" cy="140" r="35" fill="white"/>
        <circle cx="185" cy="140" r="35" fill="white"/>
        <circle cx="115" cy="140" r="20" fill="#f59e0b"/>
        <circle cx="185" cy="140" r="20" fill="#f59e0b"/>
        <circle cx="115" cy="140" r="10" fill="#1e293b"/>
        <circle cx="185" cy="140" r="10" fill="#1e293b"/>
        <polygon points="150,160 140,185 160,185" fill="#f97316"/>
        <ellipse cx="100" cy="85" rx="25" ry="20" fill="#78350f"/>
        <ellipse cx="200" cy="85" rx="25" ry="20" fill="#78350f"/>
        <path d="M80,230 L70,280" stroke="#78350f" stroke-width="12"/>
        <path d="M220,230 L230,280" stroke="#78350f" stroke-width="12"/>
        <ellipse cx="150" cy="220" rx="30" ry="15" fill="#d4a574"/>
        <path d="M120,220 L150,240 L180,220" stroke="#92400e" stroke-width="3" fill="none"/>
      </svg>`,
      rainbow: `<svg viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg">
        <rect fill="#e0f2fe" width="300" height="300"/>
        <ellipse cx="60" cy="250" rx="50" ry="30" fill="white"/>
        <ellipse cx="90" cy="260" rx="40" ry="25" fill="white"/>
        <ellipse cx="240" cy="250" rx="50" ry="30" fill="white"/>
        <ellipse cx="210" cy="260" rx="40" ry="25" fill="white"/>
        <path d="M30,250 Q150,20 270,250" stroke="#ef4444" stroke-width="20" fill="none"/>
        <path d="M50,250 Q150,50 250,250" stroke="#f97316" stroke-width="20" fill="none"/>
        <path d="M70,250 Q150,80 230,250" stroke="#fbbf24" stroke-width="20" fill="none"/>
        <path d="M90,250 Q150,110 210,250" stroke="#22c55e" stroke-width="20" fill="none"/>
        <path d="M110,250 Q150,140 190,250" stroke="#3b82f6" stroke-width="20" fill="none"/>
        <path d="M130,250 Q150,170 170,250" stroke="#8b5cf6" stroke-width="20" fill="none"/>
        <circle cx="70" cy="80" r="25" fill="#fbbf24"/>
        <line x1="70" y1="45" x2="70" y2="25" stroke="#fbbf24" stroke-width="4"/>
        <line x1="40" y1="60" x2="25" y2="50" stroke="#fbbf24" stroke-width="4"/>
        <line x1="100" y1="60" x2="115" y2="50" stroke="#fbbf24" stroke-width="4"/>
        <line x1="40" y1="100" x2="25" y2="110" stroke="#fbbf24" stroke-width="4"/>
        <line x1="100" y1="100" x2="115" y2="110" stroke="#fbbf24" stroke-width="4"/>
      </svg>`,
      star: `<svg viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg">
        <rect fill="#312e81" width="300" height="300"/>
        <circle cx="50" cy="50" r="2" fill="white"/><circle cx="100" cy="80" r="1" fill="white"/>
        <circle cx="200" cy="40" r="2" fill="white"/><circle cx="250" cy="100" r="1" fill="white"/>
        <circle cx="30" cy="150" r="1" fill="white"/><circle cx="270" cy="200" r="2" fill="white"/>
        <circle cx="80" cy="250" r="1" fill="white"/><circle cx="220" cy="270" r="1" fill="white"/>
        <polygon points="150,30 170,100 245,100 185,145 210,220 150,175 90,220 115,145 55,100 130,100" fill="#fbbf24"/>
        <polygon points="150,60 165,110 220,110 175,140 195,195 150,165 105,195 125,140 80,110 135,110" fill="#fde047"/>
        <circle cx="150" cy="130" r="25" fill="#fbbf24"/>
        <circle cx="140" cy="125" r="5" fill="#1e293b"/>
        <circle cx="160" cy="125" r="5" fill="#1e293b"/>
        <path d="M140,145 Q150,155 160,145" stroke="#1e293b" stroke-width="3" fill="none"/>
        <circle cx="130" cy="115" r="8" fill="#fca5a5" opacity="0.5"/>
        <circle cx="170" cy="115" r="8" fill="#fca5a5" opacity="0.5"/>
      </svg>`
    };

    const PUZZLES = [
      {
        id: 0,
        name: "Chevalier",
        theme: "knight",
        bgColor: "from-amber-100 to-yellow-200",
        borderColor: "border-amber-400",
      },
      {
        id: 1,
        name: "Pirate",
        theme: "pirate",
        bgColor: "from-sky-100 to-blue-200",
        borderColor: "border-sky-400",
      },
      {
        id: 2,
        name: "Dragon",
        theme: "dragon",
        bgColor: "from-red-100 to-orange-200",
        borderColor: "border-red-400",
      },
      {
        id: 3,
        name: "Licorne",
        theme: "unicorn",
        bgColor: "from-pink-100 to-purple-200",
        borderColor: "border-pink-400",
      },
      {
        id: 4,
        name: "Robot",
        theme: "robot",
        bgColor: "from-slate-100 to-cyan-200",
        borderColor: "border-slate-400",
      },
      {
        id: 5,
        name: "Fus√©e",
        theme: "rocket",
        bgColor: "from-indigo-900 to-purple-900",
        borderColor: "border-indigo-400",
      },
      {
        id: 6,
        name: "Chat",
        theme: "cat",
        bgColor: "from-yellow-100 to-orange-200",
        borderColor: "border-orange-400",
      },
      {
        id: 7,
        name: "Hibou",
        theme: "owl",
        bgColor: "from-amber-100 to-amber-200",
        borderColor: "border-amber-500",
      },
      {
        id: 8,
        name: "Arc-en-ciel",
        theme: "rainbow",
        bgColor: "from-sky-100 to-pink-100",
        borderColor: "border-sky-400",
      },
      {
        id: 9,
        name: "√âtoile",
        theme: "star",
        bgColor: "from-indigo-200 to-yellow-100",
        borderColor: "border-yellow-400",
      },
    ];

    // ========== CONFETTI COMPONENT ==========
    function Confetti({ count = 50 }) {
      const colors = ['#f472b6', '#a78bfa', '#60a5fa', '#34d399', '#fbbf24', '#f87171'];
      const confetti = Array.from({ length: count }, (_, i) => ({
        id: i,
        left: Math.random() * 100,
        delay: Math.random() * 0.5,
        color: colors[Math.floor(Math.random() * colors.length)],
        size: 8 + Math.random() * 8,
        duration: 2 + Math.random() * 2,
      }));

      return (
        <div className="confetti-container">
          {confetti.map(c => (
            <div
              key={c.id}
              className="confetti"
              style={{
                left: `${c.left}%`,
                backgroundColor: c.color,
                width: c.size,
                height: c.size,
                borderRadius: Math.random() > 0.5 ? '50%' : '2px',
                animationDelay: `${c.delay}s`,
                animationDuration: `${c.duration}s`,
              }}
            />
          ))}
        </div>
      );
    }

    // ========== BREAKOUT GAME ==========
    // Level patterns (1 = brick, 0 = empty, 2 = powerup brick)
    const LEVELS = [
      { name: "Classique", pattern: [
        [1,1,1,1,1,1,1,1],
        [1,1,1,1,1,1,1,1],
        [1,1,2,1,1,2,1,1],
        [1,1,1,1,1,1,1,1],
        [1,1,1,1,1,1,1,1],
      ]},
      { name: "Pyramide", pattern: [
        [0,0,0,1,1,0,0,0],
        [0,0,1,1,1,1,0,0],
        [0,1,1,2,2,1,1,0],
        [1,1,1,1,1,1,1,1],
        [1,1,1,1,1,1,1,1],
      ]},
      { name: "Damier", pattern: [
        [1,0,1,0,1,0,1,0],
        [0,1,0,1,0,1,0,1],
        [1,0,2,0,1,0,2,0],
        [0,1,0,1,0,1,0,1],
        [1,0,1,0,1,0,1,0],
      ]},
      { name: "Coeur", pattern: [
        [0,1,1,0,0,1,1,0],
        [1,1,1,1,1,1,1,1],
        [1,1,2,1,1,2,1,1],
        [0,1,1,1,1,1,1,0],
        [0,0,1,1,1,1,0,0],
      ]},
      { name: "Forteresse", pattern: [
        [1,0,0,1,1,0,0,1],
        [1,1,1,1,1,1,1,1],
        [1,2,1,0,0,1,2,1],
        [1,1,1,1,1,1,1,1],
        [1,0,0,1,1,0,0,1],
      ]},
    ];

    function BreakoutGame({ lives, onLoseLife, onExit }) {
      const canvasRef = useRef(null);
      const [gameState, setGameState] = useState('ready'); // ready, playing, won, lost, levelComplete
      const [score, setScore] = useState(0);
      const [currentLives, setCurrentLives] = useState(lives);
      // Charger le niveau sauvegard√©
      const [level, setLevel] = useState(() => parseInt(localStorage.getItem('breakoutLevel') || '0', 10));
      const [powerUps, setPowerUps] = useState({ wide: 0, slow: 0 }); // temps restant en secondes
      const gameRef = useRef({});
      const powerUpsRef = useRef({ wide: 0, slow: 0 }); // Pour acc√®s dans gameLoop
      const cheatBufferRef = useRef([]);

      // Sauvegarder le niveau
      useEffect(() => {
        localStorage.setItem('breakoutLevel', level.toString());
      }, [level]);

      // Cheat code $$$ pour victoire instantan√©e
      useEffect(() => {
        const handleKeyDown = (e) => {
          if (e.key === '$') {
            cheatBufferRef.current.push(Date.now());
            if (cheatBufferRef.current.length > 3) cheatBufferRef.current.shift();
            if (cheatBufferRef.current.length === 3) {
              const timeDiff = cheatBufferRef.current[2] - cheatBufferRef.current[0];
              if (timeDiff < 2000) {
                // D√©truire toutes les briques
                if (gameRef.current.bricks) {
                  gameRef.current.bricks.forEach(b => b.alive = false);
                }
                cheatBufferRef.current = [];
              }
            }
          }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, []);

      const initLevel = (lvl) => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const W = canvas.width = 320;
        const H = canvas.height = 480;
        const pattern = LEVELS[lvl % LEVELS.length].pattern;
        const colors = ['#ef4444', '#f97316', '#eab308', '#22c55e', '#3b82f6'];
        const brickW = 36, brickH = 15, brickPad = 3, brickTop = 50;
        const bricks = [];

        pattern.forEach((row, r) => {
          row.forEach((cell, c) => {
            if (cell > 0) {
              // Briques m√©tal : 2 coups √† partir niveau 2, 3 coups √† partir niveau 4
              // Certaines briques al√©atoires deviennent m√©tal
              let hp = 1;
              let isMetal = false;
              if (lvl >= 1 && Math.random() < 0.3) { // 30% de chances
                hp = 2;
                isMetal = true;
              }
              if (lvl >= 3 && Math.random() < 0.2) { // 20% de chances de 3HP
                hp = 3;
                isMetal = true;
              }
              bricks.push({
                x: c * (brickW + brickPad) + 10,
                y: r * (brickH + brickPad) + brickTop,
                w: brickW, h: brickH,
                alive: true,
                color: colors[r],
                hasPowerUp: cell === 2,
                hp: hp,
                maxHp: hp,
                isMetal: isMetal
              });
            }
          });
        });

        const baseW = powerUpsRef.current.wide > 0 ? 120 : 90;
        const paddle = { x: W/2 - baseW/2, y: H - 30, w: baseW, h: 12 };
        const speed = powerUpsRef.current.slow > 0 ? 2 : 2.5;
        const ball = { x: W/2, y: H - 50, r: 8, dx: 0, dy: 0, speed, launched: false };
        const fallingPowerUps = []; // power-ups qui tombent
        const particles = []; // particules d'effet

        gameRef.current = { paddle, ball, bricks, fallingPowerUps, particles, running: false, score: gameRef.current.score || 0, W, H };
        draw();
      };

      const draw = () => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const { paddle, ball, bricks, fallingPowerUps, W, H } = gameRef.current;
        const pups = powerUpsRef.current;

        // Background gradient
        const bgGradient = ctx.createLinearGradient(0, 0, 0, H);
        bgGradient.addColorStop(0, '#1e1b4b');
        bgGradient.addColorStop(1, '#0f0a2e');
        ctx.fillStyle = bgGradient;
        ctx.fillRect(0, 0, W, H);
        // Stars effect
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        for (let i = 0; i < 20; i++) {
          const sx = (i * 37 + level * 13) % W;
          const sy = (i * 23 + level * 7) % (H - 100);
          ctx.beginPath();
          ctx.arc(sx, sy, 1, 0, Math.PI * 2);
          ctx.fill();
        }

        // Paddle with gradient
        const paddleGradient = ctx.createLinearGradient(paddle.x, paddle.y, paddle.x, paddle.y + paddle.h);
        if (pups.wide > 0) {
          paddleGradient.addColorStop(0, '#4ade80');
          paddleGradient.addColorStop(1, '#16a34a');
        } else {
          paddleGradient.addColorStop(0, '#a78bfa');
          paddleGradient.addColorStop(1, '#7c3aed');
        }
        ctx.fillStyle = paddleGradient;
        ctx.beginPath();
        ctx.roundRect(paddle.x, paddle.y, paddle.w, paddle.h, 6);
        ctx.fill();
        // Paddle shine
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.beginPath();
        ctx.roundRect(paddle.x + 4, paddle.y + 2, paddle.w - 8, 4, 2);
        ctx.fill();

        // Ball with glow effect
        const ballColor = pups.slow > 0 ? '#60a5fa' : '#fbbf24';
        const glowColor = pups.slow > 0 ? 'rgba(96, 165, 250, 0.4)' : 'rgba(251, 191, 36, 0.4)';
        // Glow
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r + 4, 0, Math.PI * 2);
        ctx.fillStyle = glowColor;
        ctx.fill();
        // Ball
        ctx.fillStyle = ballColor;
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
        ctx.fill();
        // Shine
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.beginPath();
        ctx.arc(ball.x - 2, ball.y - 2, ball.r / 3, 0, Math.PI * 2);
        ctx.fill();

        // Bricks
        bricks.forEach(b => {
          if (b.alive) {
            // Couleur de base ou m√©tal
            if (b.isMetal) {
              // D√©grad√© m√©tallique gris
              const gradient = ctx.createLinearGradient(b.x, b.y, b.x, b.y + b.h);
              gradient.addColorStop(0, '#9ca3af');
              gradient.addColorStop(0.5, '#6b7280');
              gradient.addColorStop(1, '#4b5563');
              ctx.fillStyle = gradient;
            } else {
              ctx.fillStyle = b.color;
            }
            ctx.beginPath();
            ctx.roundRect(b.x, b.y, b.w, b.h, 3);
            ctx.fill();

            // Bordure m√©tallique
            if (b.isMetal) {
              ctx.strokeStyle = '#d1d5db';
              ctx.lineWidth = 1;
              ctx.stroke();
            }

            // Fissures selon les d√©g√¢ts
            if (b.isMetal && b.hp < b.maxHp) {
              ctx.strokeStyle = '#1f2937';
              ctx.lineWidth = 2;
              ctx.beginPath();
              if (b.maxHp - b.hp >= 1) {
                // Premi√®re fissure
                ctx.moveTo(b.x + b.w * 0.3, b.y);
                ctx.lineTo(b.x + b.w * 0.5, b.y + b.h * 0.5);
                ctx.lineTo(b.x + b.w * 0.4, b.y + b.h);
              }
              if (b.maxHp - b.hp >= 2) {
                // Deuxi√®me fissure
                ctx.moveTo(b.x + b.w * 0.7, b.y);
                ctx.lineTo(b.x + b.w * 0.6, b.y + b.h * 0.6);
                ctx.lineTo(b.x + b.w * 0.8, b.y + b.h);
              }
              ctx.stroke();
            }

            // Indicateur HP pour m√©tal
            if (b.isMetal) {
              ctx.fillStyle = 'white';
              ctx.font = 'bold 9px sans-serif';
              ctx.fillText(b.hp.toString(), b.x + b.w/2 - 3, b.y + b.h/2 + 3);
            }

            if (b.hasPowerUp && !b.isMetal) {
              ctx.fillStyle = 'white';
              ctx.font = 'bold 10px sans-serif';
              ctx.fillText('‚≠ê', b.x + b.w/2 - 5, b.y + b.h/2 + 4);
            }
          }
        });

        // Falling powerups
        fallingPowerUps.forEach(p => {
          ctx.fillStyle = p.type === 'wide' ? '#22c55e' : p.type === 'slow' ? '#60a5fa' : '#f472b6';
          ctx.beginPath();
          ctx.arc(p.x, p.y, 10, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = 'white';
          ctx.font = 'bold 12px sans-serif';
          ctx.fillText(p.type === 'wide' ? '‚Üî' : p.type === 'slow' ? 'üê¢' : '√ó2', p.x - 6, p.y + 4);
        });

        // Particles
        const { particles } = gameRef.current;
        particles.forEach(p => {
          ctx.globalAlpha = p.life;
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
          ctx.fill();
        });
        ctx.globalAlpha = 1;

        // UI
        ctx.fillStyle = 'white';
        ctx.font = 'bold 14px sans-serif';
        ctx.fillText(`Niveau ${level + 1}`, 10, 20);
        ctx.fillText(`Score: ${gameRef.current.score}`, W/2 - 30, 20);
        ctx.fillText(`‚ù§Ô∏è√ó${currentLives}`, W - 50, 20);

        // Affichage des power-ups actifs avec temps restant
        let puY = 38;
        if (pups.wide > 0) {
          ctx.fillStyle = '#22c55e';
          ctx.fillText(`‚Üî ${Math.ceil(pups.wide)}s`, 10, puY);
          puY += 16;
        }
        if (pups.slow > 0) {
          ctx.fillStyle = '#60a5fa';
          ctx.fillText(`üê¢ ${Math.ceil(pups.slow)}s`, 10, puY);
        }

        if (!ball.launched && gameState === 'ready') {
          ctx.fillStyle = 'rgba(255,255,255,0.8)';
          ctx.font = 'bold 16px sans-serif';
          ctx.fillText('Clique pour lancer !', W/2 - 70, H/2);
        }
      };

      useEffect(() => {
        initLevel(level);
      }, [level]);

      // Timer pour d√©cr√©menter les power-ups actifs
      useEffect(() => {
        const interval = setInterval(() => {
          setPowerUps(prev => {
            const next = { ...prev };
            let changed = false;
            if (next.wide > 0) { next.wide = Math.max(0, next.wide - 0.1); changed = true; }
            if (next.slow > 0) { next.slow = Math.max(0, next.slow - 0.1); changed = true; }
            return changed ? next : prev;
          });
        }, 100); // D√©cr√©mente toutes les 100ms
        return () => clearInterval(interval);
      }, []);

      // Appliquer les power-ups sans r√©initialiser le niveau
      useEffect(() => {
        powerUpsRef.current = powerUps;
        if (!gameRef.current.paddle) return;
        const { paddle, ball } = gameRef.current;
        const wasWide = paddle.w === 120;
        const shouldBeWide = powerUps.wide > 0;
        if (wasWide !== shouldBeWide) {
          paddle.w = shouldBeWide ? 120 : 90;
        }
        const wasSlow = ball.speed === 2;
        const shouldBeSlow = powerUps.slow > 0;
        if (wasSlow !== shouldBeSlow) {
          const newSpeed = shouldBeSlow ? 2 : 2.5;
          if (ball.launched) {
            const ratio = newSpeed / ball.speed;
            ball.dx *= ratio;
            ball.dy *= ratio;
          }
          ball.speed = newSpeed;
        }
        if (!gameRef.current.running) draw();
      }, [powerUps]);

      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        const handleMove = (clientX) => {
          const rect = canvas.getBoundingClientRect();
          const x = (clientX - rect.left) * (canvas.width / rect.width);
          const { paddle, ball, W } = gameRef.current;
          paddle.x = Math.max(0, Math.min(W - paddle.w, x - paddle.w/2));
          if (!ball.launched) {
            ball.x = paddle.x + paddle.w/2;
          }
          if (!gameRef.current.running) draw();
        };

        const handleClick = () => {
          if (gameState !== 'ready' || currentLives <= 0) return;
          const { ball } = gameRef.current;
          if (!ball.launched) {
            ball.launched = true;
            ball.dx = ball.speed * (Math.random() > 0.5 ? 1 : -1);
            ball.dy = -ball.speed;
            gameRef.current.running = true;
            setGameState('playing');
            gameLoop();
          }
        };

        const handleMouse = (e) => handleMove(e.clientX);
        const handleTouch = (e) => { e.preventDefault(); handleMove(e.touches[0].clientX); };
        const handleTouchStart = (e) => { e.preventDefault(); handleClick(); };

        canvas.addEventListener('mousemove', handleMouse);
        canvas.addEventListener('click', handleClick);
        canvas.addEventListener('touchmove', handleTouch, { passive: false });
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });

        return () => {
          canvas.removeEventListener('mousemove', handleMouse);
          canvas.removeEventListener('click', handleClick);
          canvas.removeEventListener('touchmove', handleTouch);
          canvas.removeEventListener('touchstart', handleTouchStart);
        };
      }, [gameState, currentLives, level]);

      const gameLoop = () => {
        if (!gameRef.current.running) return;
        const { paddle, ball, bricks, fallingPowerUps, particles, W, H } = gameRef.current;

        ball.x += ball.dx;
        ball.y += ball.dy;

        // Wall collision
        if (ball.x - ball.r < 0 || ball.x + ball.r > W) ball.dx *= -1;
        if (ball.y - ball.r < 0) ball.dy *= -1;

        // Paddle collision
        if (ball.y + ball.r > paddle.y && ball.y + ball.r < paddle.y + paddle.h + 5 &&
            ball.x > paddle.x - ball.r && ball.x < paddle.x + paddle.w + ball.r) {
          ball.dy = -Math.abs(ball.dy);
          const hitPos = (ball.x - paddle.x) / paddle.w;
          ball.dx = (hitPos - 0.5) * ball.speed * 2.5;
        }

        // Brick collision
        bricks.forEach(b => {
          if (b.alive &&
              ball.x + ball.r > b.x && ball.x - ball.r < b.x + b.w &&
              ball.y + ball.r > b.y && ball.y - ball.r < b.y + b.h) {
            // R√©duire HP
            b.hp = (b.hp || 1) - 1;
            ball.dy *= -1;

            // Spawn particles
            const color = b.isMetal ? '#9ca3af' : b.color;
            const particleCount = b.hp <= 0 ? 12 : 4;
            for (let i = 0; i < particleCount; i++) {
              particles.push({
                x: b.x + b.w / 2,
                y: b.y + b.h / 2,
                dx: (Math.random() - 0.5) * 4,
                dy: (Math.random() - 0.5) * 4,
                size: Math.random() * 4 + 2,
                color: color,
                life: 1
              });
            }

            if (b.hp <= 0) {
              b.alive = false;
              gameRef.current.score += (b.isMetal ? 20 : 10) * (level + 1);
              // Drop powerup
              if (b.hasPowerUp) {
                const types = ['wide', 'slow', 'wide'];
                fallingPowerUps.push({ x: b.x + b.w/2, y: b.y, type: types[Math.floor(Math.random() * types.length)] });
              }
            } else {
              // Points bonus pour toucher m√©tal
              gameRef.current.score += 5 * (level + 1);
            }
            setScore(gameRef.current.score);
          }
        });

        // Update falling powerups
        for (let i = fallingPowerUps.length - 1; i >= 0; i--) {
          const p = fallingPowerUps[i];
          p.y += 1;
          if (p.y > paddle.y && p.y < paddle.y + paddle.h + 15 &&
              p.x > paddle.x && p.x < paddle.x + paddle.w) {
            // Ajouter 10 secondes au power-up (cumulable)
            setPowerUps(prev => ({ ...prev, [p.type]: prev[p.type] + 10 }));
            fallingPowerUps.splice(i, 1);
          } else if (p.y > H) {
            fallingPowerUps.splice(i, 1);
          }
        }

        // Update particles
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.x += p.dx;
          p.y += p.dy;
          p.dy += 0.1; // gravity
          p.life -= 0.03;
          if (p.life <= 0) particles.splice(i, 1);
        }

        // Check win
        if (bricks.every(b => !b.alive)) {
          gameRef.current.running = false;
          if (level < LEVELS.length - 1) {
            setGameState('levelComplete');
          } else {
            setGameState('won');
          }
          return;
        }

        // Ball lost
        if (ball.y > H) {
          gameRef.current.running = false;
          const newLives = currentLives - 1;
          setCurrentLives(newLives);
          onLoseLife();
          if (newLives <= 0) {
            setGameState('lost');
          } else {
            ball.x = paddle.x + paddle.w/2;
            ball.y = H - 50;
            ball.dx = 0; ball.dy = 0;
            ball.launched = false;
            setGameState('ready');
          }
          return;
        }

        draw();
        requestAnimationFrame(gameLoop);
      };

      const nextLevel = () => {
        setLevel(l => l + 1);
        setGameState('ready');
      };

      const restart = () => {
        setLevel(0);
        setScore(0);
        gameRef.current.score = 0;
        setCurrentLives(lives);
        setPowerUp(null);
        setGameState('ready');
      };

      return (
        <div className="min-h-screen bg-gradient-to-br from-indigo-900 via-purple-900 to-pink-900 flex flex-col items-center justify-center p-4">
          <div className="bg-white/10 backdrop-blur-lg rounded-3xl p-4 shadow-2xl border border-white/20">
            <div className="flex justify-between items-center mb-3">
              <button onClick={onExit} className="text-purple-300 hover:text-white transition text-sm">‚Üê Quitter</button>
              <h2 className="text-lg font-bold text-white">üéÆ {LEVELS[level % LEVELS.length].name}</h2>
              <div className="text-purple-300 text-sm">Niv.{level + 1}</div>
            </div>

            {(powerUps.wide > 0 || powerUps.slow > 0) && (
              <div className="flex justify-center gap-2 mb-2">
                {powerUps.wide > 0 && (
                  <div className="text-sm py-1 px-3 rounded-full bg-green-500/30 text-green-300">
                    ‚ÜîÔ∏è {Math.ceil(powerUps.wide)}s
                  </div>
                )}
                {powerUps.slow > 0 && (
                  <div className="text-sm py-1 px-3 rounded-full bg-blue-500/30 text-blue-300">
                    üê¢ {Math.ceil(powerUps.slow)}s
                  </div>
                )}
              </div>
            )}

            <canvas
              ref={canvasRef}
              className="rounded-xl bg-indigo-950 touch-none cursor-pointer"
              style={{ maxWidth: '100%' }}
            />

            {gameState === 'levelComplete' && (
              <div className="text-center mt-4 animate-pop">
                <div className="text-4xl mb-2">üéâ</div>
                <div className="text-xl font-bold text-green-400 mb-2">Niveau {level + 1} termin√© !</div>
                <button onClick={nextLevel} className="px-6 py-3 rounded-xl bg-gradient-to-r from-green-400 to-emerald-500 text-white font-bold">
                  Niveau suivant ‚Üí
                </button>
              </div>
            )}

            {gameState === 'won' && (
              <div className="text-center mt-4 animate-pop">
                <div className="text-4xl mb-2">üèÜ</div>
                <div className="text-2xl font-bold text-yellow-400 mb-2">Tous les niveaux battus !</div>
                <div className="text-purple-300 mb-4">Score final : {score}</div>
                <button onClick={restart} className="px-6 py-3 rounded-xl bg-purple-500 text-white font-bold mr-2">
                  Rejouer
                </button>
                <button onClick={onExit} className="px-6 py-3 rounded-xl bg-white/20 text-white font-bold">
                  Quitter
                </button>
              </div>
            )}

            {gameState === 'lost' && (
              <div className="text-center mt-4">
                <div className="text-4xl mb-2">üíî</div>
                <div className="text-xl font-bold text-red-400 mb-2">Plus de vies !</div>
                <div className="text-purple-300 mb-4">Score : {score}</div>
                <button onClick={onExit} className="px-6 py-3 rounded-xl bg-purple-500 text-white font-bold">
                  Retour
                </button>
              </div>
            )}

            <div className="mt-3 flex justify-between text-purple-300 text-xs">
              <span>‚ù§Ô∏è √ó {currentLives}</span>
              <span>Score: {score}</span>
            </div>
          </div>
        </div>
      );
    }

    // ========== PUZZLE GRID COMPONENT ==========
    function PuzzleGrid({ puzzle, pieces, size = 'md', animate = false }) {
      const svgData = PUZZLE_IMAGES[puzzle.theme];
      const sizeClasses = {
        sm: 'w-24 h-24',
        md: 'w-48 h-48',
        lg: 'w-64 h-64'
      };

      return (
        <div className={`${sizeClasses[size]} grid grid-cols-3 grid-rows-3 gap-0.5 rounded-xl overflow-hidden bg-gray-300`}>
          {pieces.map((unlocked, i) => {
            const row = Math.floor(i / 3);
            const col = i % 3;
            return (
              <div
                key={i}
                className={`relative overflow-hidden ${animate && unlocked ? 'animate-puzzle-reveal' : ''}`}
                style={animate ? { animationDelay: `${i * 0.1}s` } : {}}
              >
                {unlocked ? (
                  <div
                    className="w-full h-full"
                    style={{
                      backgroundImage: `url("data:image/svg+xml,${encodeURIComponent(svgData)}")`,
                      backgroundSize: '300% 300%',
                      backgroundPosition: `${col * 50}% ${row * 50}%`
                    }}
                  />
                ) : (
                  <div className="w-full h-full bg-gray-400 flex items-center justify-center text-gray-500 text-lg font-bold">
                    ?
                  </div>
                )}
              </div>
            );
          })}
        </div>
      );
    }

    // ========== ACHIEVEMENTS ==========
    const ACHIEVEMENTS = {
      first_game:     { icon: "üéÆ", name: "Premier pas",      desc: "Terminer une partie" },
      perfect:        { icon: "üíØ", name: "Perfect",          desc: "10/10 sur une partie" },
      streak_5:       { icon: "üî•", name: "En feu",           desc: "5 bonnes r√©ponses d'affil√©e" },
      streak_10:      { icon: "‚ö°", name: "Inarr√™table",      desc: "10 bonnes r√©ponses d'affil√©e" },
      speed_demon:    { icon: "üöÄ", name: "Speed Demon",      desc: "10/10 en mode Expert" },
      veteran:        { icon: "üéñÔ∏è", name: "V√©t√©ran",          desc: "10 parties jou√©es" },
      master:         { icon: "üëë", name: "Ma√Ætre",           desc: "50 parties jou√©es" },
      perfectionist:  { icon: "‚ú®", name: "Perfectionniste",  desc: "5 parties parfaites" },
      scholar:        { icon: "üìö", name: "√ârudit",           desc: "500 bonnes r√©ponses" },
      lightning:      { icon: "‚ö°", name: "√âclair",           desc: "10 r√©ponses en moins de 2s" },
    };

    function checkAchievements(stats, gameData) {
      const newAchievements = [];
      const { results, difficulty, currentStreak } = gameData;
      const correctCount = results.filter(r => r.correct).length;
      const isPerfect = correctCount === results.length;

      if (!stats.achievements.includes('first_game')) newAchievements.push('first_game');
      if (isPerfect && !stats.achievements.includes('perfect')) newAchievements.push('perfect');
      if (isPerfect && difficulty === 'expert' && !stats.achievements.includes('speed_demon')) newAchievements.push('speed_demon');
      if (currentStreak >= 5 && !stats.achievements.includes('streak_5')) newAchievements.push('streak_5');
      if (currentStreak >= 10 && !stats.achievements.includes('streak_10')) newAchievements.push('streak_10');
      if (stats.gamesPlayed + 1 >= 10 && !stats.achievements.includes('veteran')) newAchievements.push('veteran');
      if (stats.gamesPlayed + 1 >= 50 && !stats.achievements.includes('master')) newAchievements.push('master');
      if (isPerfect && stats.perfectGames + 1 >= 5 && !stats.achievements.includes('perfectionist')) newAchievements.push('perfectionist');
      if (stats.totalCorrect + correctCount >= 500 && !stats.achievements.includes('scholar')) newAchievements.push('scholar');
      if (stats.fastAnswers >= 10 && !stats.achievements.includes('lightning')) newAchievements.push('lightning');

      return newAchievements;
    }

    const DIFFICULTY = {
      zen:    { label: "Zen",     timer: 0,  multiplier: 0.5, color: "from-sky-400 to-blue-500" },
      easy:   { label: "Facile",  timer: 12, multiplier: 1,   color: "from-green-500 to-emerald-500" },
      normal: { label: "Normal",  timer: 8,  multiplier: 1.5, color: "from-yellow-500 to-orange-500" },
      expert: { label: "Expert",  timer: 4,  multiplier: 2,   color: "from-red-500 to-pink-500" },
    };

    const MODES = {
      multiplication: { label: "Multiplication", symbol: "√ó", icon: "‚úï", color: "from-violet-500 to-purple-400" },
      division:       { label: "Division",       symbol: "√∑", icon: "√∑", color: "from-rose-400 to-pink-500" },
      addition:       { label: "Addition",       symbol: "+", icon: "+", color: "from-emerald-400 to-teal-500" },
      subtraction:    { label: "Soustraction",   symbol: "‚àí", icon: "‚àí", color: "from-amber-400 to-orange-500" },
    };

    function generateQuestions(mode, config) {
      const pool = [];

      if (mode === 'multiplication') {
        const maxB = config.maxTable || 12;
        config.tables.forEach(table => {
          for (let i = 2; i <= maxB; i++) {
            pool.push({ a: table, b: i, answer: table * i, op: '√ó' });
          }
        });
      } else if (mode === 'division') {
        const maxB = config.maxTable || 12;
        config.tables.forEach(table => {
          for (let i = 2; i <= maxB; i++) {
            const product = table * i;
            pool.push({ a: product, b: i, answer: table, op: '√∑' });
          }
        });
      } else if (mode === 'addition') {
        for (let i = 0; i < 50; i++) {
          const a = Math.floor(Math.random() * (config.max - config.min + 1)) + config.min;
          const b = Math.floor(Math.random() * (config.max - config.min + 1)) + config.min;
          pool.push({ a, b, answer: a + b, op: '+' });
        }
      } else if (mode === 'subtraction') {
        for (let i = 0; i < 50; i++) {
          const a = Math.floor(Math.random() * (config.max - config.min + 1)) + config.min;
          const b = Math.floor(Math.random() * (a - config.min + 1)) + config.min;
          pool.push({ a, b, answer: a - b, op: '‚àí' });
        }
      } else if (mode === 'kids') {
        // Mode enfant : additions et soustractions simples
        const addOps = config.addOperations || [1, 2, 3];
        const subOps = config.subOperations || [];

        for (let i = 0; i < 50; i++) {
          const a = Math.floor(Math.random() * (config.max - config.min + 1)) + config.min;

          // D√©cider si addition ou soustraction
          const allOps = [...addOps.map(n => ({type: '+', val: n})), ...subOps.map(n => ({type: '-', val: n}))];
          if (allOps.length === 0) continue;

          const op = allOps[Math.floor(Math.random() * allOps.length)];

          if (op.type === '+') {
            pool.push({ a, b: op.val, answer: a + op.val, op: '+' });
          } else {
            // Pour soustraction, s'assurer que le r√©sultat >= 0
            if (a >= op.val) {
              pool.push({ a, b: op.val, answer: a - op.val, op: '-' });
            }
          }
        }
      }

      const shuffled = [...pool].sort(() => Math.random() - 0.5);
      return shuffled.slice(0, Math.min(QUESTIONS_COUNT, shuffled.length));
    }

    // ========== KIDS MODE FEEDBACK ==========
    const KIDS_FEEDBACK = {
      correct: ["Bravo ! üåü", "Super ! ‚≠ê", "G√©nial ! üéâ", "Trop fort ! üí™", "Ouiii ! ü•≥", "Champion ! üèÜ", "Excellent ! üéä", "Parfait ! ‚ú®", "Wow ! ü§©", "Incroyable ! üåà"],
      wrong: ["Presque ! üí´", "Essaie encore ! üåà", "Pas grave ! üòä", "Tu vas y arriver ! üí™", "Continue ! üöÄ", "Courage ! üåü"],
    };

    // ========== HOME SCREEN ==========
    function HomeScreen({ onKids, onAdvanced }) {
      return (
        <div className="min-h-screen bg-gradient-to-br from-indigo-900 via-purple-900 to-pink-900 flex items-center justify-center p-4">
          <div className="w-full max-w-md animate-fade-in">
            <h1 className="text-4xl font-bold text-white text-center mb-2">üßÆ MathQuiz</h1>
            <p className="text-purple-200 text-center mb-10">Choisis ton aventure</p>

            <div className="space-y-6">
              {/* Mode Enfant */}
              <button
                onClick={onKids}
                className="w-full py-8 rounded-3xl font-bold text-2xl bg-gradient-to-r from-pink-400 via-purple-400 to-indigo-400 text-white shadow-2xl hover:scale-[1.02] transition-all duration-300 flex flex-col items-center gap-3 relative overflow-hidden group"
              >
                <div className="absolute inset-0 shine-effect opacity-30"></div>
                <span className="text-5xl animate-float">üë∂</span>
                <span>Apprendre √† compter</span>
                <span className="text-sm font-normal bg-white/20 px-3 py-1 rounded-full">GS / CP / CE1</span>
              </button>

              {/* Mode Avanc√© */}
              <button
                onClick={onAdvanced}
                className="w-full py-8 rounded-3xl font-bold text-2xl bg-gradient-to-r from-blue-600 via-indigo-600 to-violet-600 text-white shadow-2xl hover:scale-[1.02] transition-all duration-300 flex flex-col items-center gap-3 relative overflow-hidden group"
              >
                <div className="absolute inset-0 shine-effect opacity-20"></div>
                <span className="text-5xl">üß†</span>
                <span>Calcul mental avanc√©</span>
                <span className="text-sm font-normal bg-white/20 px-3 py-1 rounded-full">√ó, √∑, +, ‚àí</span>
              </button>
            </div>
          </div>
        </div>
      );
    }

    // ========== MENU SCREEN (ADVANCED) ==========
    function MenuScreen({ onSelect, onStats, stats, onBack }) {
      return (
        <div className="min-h-screen bg-gradient-to-br from-slate-900 via-blue-950 to-slate-900 flex items-center justify-center p-4">
          <div className="bg-white/10 backdrop-blur-lg rounded-3xl p-8 w-full max-w-md shadow-2xl border border-white/20 animate-fade-in">
            <button onClick={onBack} className="text-blue-300 hover:text-white mb-4 transition flex items-center gap-1">‚Üê Accueil</button>
            <h1 className="text-3xl font-bold text-white text-center mb-2">üß† Calcul Mental</h1>
            <p className="text-blue-200 text-center mb-6">Choisis ton entra√Ænement</p>

            {/* Mini stats bar */}
            <div className="flex justify-center gap-6 mb-6 text-sm">
              <div className="text-center">
                <div className="text-2xl font-bold text-white">{stats.totalScore}</div>
                <div className="text-blue-300">points</div>
              </div>
              <div className="text-center">
                <div className="text-2xl font-bold text-white">{stats.gamesPlayed}</div>
                <div className="text-blue-300">parties</div>
              </div>
              <div className="text-center">
                <div className="text-2xl font-bold text-white">{stats.achievements.length}</div>
                <div className="text-blue-300">badges</div>
              </div>
            </div>

            <div className="space-y-3 mb-6">
              {Object.entries(MODES).map(([key, mode]) => (
                <button
                  key={key}
                  onClick={() => onSelect(key)}
                  className={`w-full py-4 rounded-2xl font-bold text-lg bg-gradient-to-r ${mode.color} text-white shadow-lg hover:scale-[1.02] transition-all duration-200 flex items-center justify-center gap-3`}
                >
                  <span className="text-xl">{mode.icon}</span>
                  {mode.label}
                </button>
              ))}
            </div>

            <button
              onClick={onStats}
              className="w-full py-3 rounded-2xl font-medium text-blue-300 bg-white/10 hover:bg-white/20 transition-all flex items-center justify-center gap-2"
            >
              üèÜ Statistiques & Badges
            </button>
          </div>
        </div>
      );
    }

    // Stats Screen
    function StatsScreen({ stats, onBack, onReset }) {
      const accuracy = stats.totalQuestions > 0
        ? Math.round((stats.totalCorrect / stats.totalQuestions) * 100)
        : 0;

      return (
        <div className="min-h-screen bg-gradient-to-br from-slate-900 via-blue-950 to-slate-900 flex items-center justify-center p-4">
          <div className="bg-white/10 backdrop-blur-lg rounded-3xl p-8 w-full max-w-md shadow-2xl border border-white/20 max-h-[90vh] overflow-y-auto animate-fade-in">
            <button onClick={onBack} className="text-blue-300 hover:text-white mb-4 transition flex items-center gap-1">‚Üê Retour</button>
            <h1 className="text-2xl font-bold text-white text-center mb-6">üèÜ Statistiques</h1>

            <div className="grid grid-cols-2 gap-4 mb-8">
              <div className="bg-white/5 rounded-xl p-4 text-center">
                <div className="text-3xl font-bold text-white">{stats.totalScore}</div>
                <div className="text-blue-300 text-sm">Score total</div>
              </div>
              <div className="bg-white/5 rounded-xl p-4 text-center">
                <div className="text-3xl font-bold text-white">{stats.gamesPlayed}</div>
                <div className="text-blue-300 text-sm">Parties jou√©es</div>
              </div>
              <div className="bg-white/5 rounded-xl p-4 text-center">
                <div className="text-3xl font-bold text-white">{accuracy}%</div>
                <div className="text-blue-300 text-sm">Pr√©cision</div>
              </div>
              <div className="bg-white/5 rounded-xl p-4 text-center">
                <div className="text-3xl font-bold text-white">{stats.bestStreak}</div>
                <div className="text-blue-300 text-sm">Meilleur streak</div>
              </div>
              <div className="bg-white/5 rounded-xl p-4 text-center">
                <div className="text-3xl font-bold text-white">{stats.perfectGames}</div>
                <div className="text-blue-300 text-sm">Parties parfaites</div>
              </div>
              <div className="bg-white/5 rounded-xl p-4 text-center">
                <div className="text-3xl font-bold text-white">{stats.totalCorrect}</div>
                <div className="text-blue-300 text-sm">Bonnes r√©ponses</div>
              </div>
            </div>

            <h2 className="text-lg font-bold text-white mb-4">üéñÔ∏è Badges ({stats.achievements.length}/{Object.keys(ACHIEVEMENTS).length})</h2>
            <div className="grid grid-cols-2 gap-3 mb-6">
              {Object.entries(ACHIEVEMENTS).map(([key, ach]) => {
                const unlocked = stats.achievements.includes(key);
                return (
                  <div
                    key={key}
                    className={`rounded-xl p-3 text-center transition-all ${
                      unlocked
                        ? 'bg-gradient-to-br from-amber-500/20 to-yellow-500/20 border border-amber-500/50'
                        : 'bg-white/5 opacity-50'
                    }`}
                  >
                    <div className={`text-2xl mb-1 ${unlocked ? '' : 'grayscale'}`}>{ach.icon}</div>
                    <div className={`font-medium text-sm ${unlocked ? 'text-white' : 'text-blue-300'}`}>{ach.name}</div>
                    <div className="text-xs text-blue-400">{ach.desc}</div>
                  </div>
                );
              })}
            </div>

            <button
              onClick={onReset}
              className="w-full py-2 rounded-xl text-sm text-red-400 hover:text-red-300 hover:bg-red-500/10 transition-all"
            >
              R√©initialiser les statistiques
            </button>
          </div>
        </div>
      );
    }

    // ========== KIDS MENU ==========
    function KidsMenuScreen({ onStart, onPuzzles, onBreakout, onCheatLives, puzzleData, onBack }) {
      const currentPuzzle = PUZZLES[puzzleData.currentPuzzle];
      const piecesCollected = puzzleData.puzzles[puzzleData.currentPuzzle].pieces.filter(p => p).length;
      const completedPuzzles = puzzleData.puzzles.filter(p => p.completed).length;
      const totalLives = puzzleData.puzzles.reduce((sum, p) => sum + (p.lives || 0), 0);
      const cheatBufferRef = React.useRef([]);

      // Cheat code: triple $ pour acc√®s direct au casse-brique
      React.useEffect(() => {
        const handleKeyDown = (e) => {
          if (e.key === '$') {
            cheatBufferRef.current.push(Date.now());
            // Garde seulement les 3 derniers
            if (cheatBufferRef.current.length > 3) cheatBufferRef.current.shift();
            // V√©rifie si 3 $ en moins de 2 secondes
            if (cheatBufferRef.current.length === 3) {
              const timeDiff = cheatBufferRef.current[2] - cheatBufferRef.current[0];
              if (timeDiff < 2000) {
                onCheatLives && onCheatLives(99);
                cheatBufferRef.current = [];
              }
            }
          }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [onCheatLives]);

      return (
        <div className="min-h-screen bg-gradient-to-br from-pink-100 via-purple-100 to-indigo-100 flex items-center justify-center p-4">
          <div className="bg-white/80 backdrop-blur-lg rounded-3xl p-8 w-full max-w-md shadow-2xl border-4 border-purple-300 animate-fade-in">
            <button onClick={onBack} className="text-purple-500 hover:text-purple-700 mb-4 transition text-lg">‚Üê Accueil</button>
            <h1 className="text-3xl font-bold text-purple-600 text-center mb-2">üë∂ Apprendre √† compter</h1>
            <p className="text-purple-400 text-center mb-6">En s'amusant !</p>

            {/* Puzzle progress */}
            <div className="bg-gradient-to-r from-amber-50 to-yellow-50 rounded-2xl p-4 mb-6 border-2 border-amber-200">
              <div className="flex justify-between items-center mb-3">
                <span className="text-amber-700 font-medium">üß© {currentPuzzle.name}</span>
                <span className="text-amber-600 font-bold">{piecesCollected}/9</span>
              </div>
              <div className="flex justify-center mb-2">
                <PuzzleGrid
                  puzzle={currentPuzzle}
                  pieces={puzzleData.puzzles[puzzleData.currentPuzzle].pieces}
                  size="sm"
                />
              </div>
              <div className="text-center text-amber-500 text-sm">
                {completedPuzzles} puzzle{completedPuzzles > 1 ? 's' : ''} compl√©t√©{completedPuzzles > 1 ? 's' : ''}
              </div>
            </div>

            {/* Start button */}
            <button
              onClick={onStart}
              className="w-full py-5 mb-4 rounded-2xl font-bold text-2xl bg-gradient-to-r from-green-400 to-emerald-500 text-white shadow-lg hover:scale-[1.02] transition-all animate-pulse-slow"
            >
              üöÄ Jouer !
            </button>

            {/* Breakout game button */}
            <button
              onClick={onBreakout}
              disabled={totalLives === 0}
              className={`w-full py-4 mb-4 rounded-2xl font-bold text-lg transition-all flex items-center justify-center gap-2 ${
                totalLives > 0
                  ? 'bg-gradient-to-r from-indigo-400 to-purple-500 text-white shadow-lg hover:scale-[1.02]'
                  : 'bg-gray-200 text-gray-400 cursor-not-allowed'
              }`}
            >
              üéÆ Casse-Brique
              {totalLives > 0 ? (
                <span className="bg-white/20 px-2 py-0.5 rounded-full text-sm">‚ù§Ô∏è {totalLives}</span>
              ) : (
                <span className="text-sm font-normal">(Compl√®te un puzzle !)</span>
              )}
            </button>

            {/* View puzzles */}
            <button
              onClick={onPuzzles}
              className="w-full py-4 rounded-2xl font-bold text-lg bg-purple-100 text-purple-600 hover:bg-purple-200 transition-all flex items-center justify-center gap-2"
            >
              üß© Voir mes puzzles
            </button>
          </div>
        </div>
      );
    }

    // ========== KIDS CONFIG ==========
    function KidsConfig({ onStart, onBack }) {
      const [addOperations, setAddOperations] = useState(new Set([1, 2, 3]));
      const [subOperations, setSubOperations] = useState(new Set());
      const [min, setMin] = useState(10);
      const [max, setMax] = useState(30);

      const toggleAddOp = (n) => {
        const next = new Set(addOperations);
        if (next.has(n)) {
          if (next.size > 1 || subOperations.size > 0) next.delete(n);
        } else {
          next.add(n);
        }
        setAddOperations(next);
      };

      const toggleSubOp = (n) => {
        const next = new Set(subOperations);
        if (next.has(n)) {
          next.delete(n);
        } else {
          next.add(n);
        }
        // S'assurer qu'on a au moins une op√©ration
        if (next.size === 0 && addOperations.size === 0) {
          setAddOperations(new Set([1]));
        }
        setSubOperations(next);
      };

      const presets = [
        { label: "10-20", min: 10, max: 20, desc: "D√©butant" },
        { label: "10-50", min: 10, max: 50, desc: "GS/CP" },
        { label: "20-100", min: 20, max: 100, desc: "CP/CE1" },
      ];

      const canStart = addOperations.size > 0 || subOperations.size > 0;

      return (
        <div className="min-h-screen bg-gradient-to-br from-pink-100 via-purple-100 to-indigo-100 flex items-center justify-center p-4">
          <div className="bg-white/80 backdrop-blur-lg rounded-3xl p-8 w-full max-w-md shadow-2xl border-4 border-purple-300 animate-fade-in max-h-[90vh] overflow-y-auto">
            <button onClick={onBack} className="text-purple-500 hover:text-purple-700 mb-4 transition text-lg">‚Üê Retour</button>
            <h1 className="text-3xl font-bold text-purple-600 text-center mb-2">‚öôÔ∏è Param√®tres</h1>
            <p className="text-purple-400 text-center mb-6">Personnalise ton entra√Ænement</p>

            {/* Additions */}
            <div className="mb-6">
              <p className="text-green-600 text-center font-bold mb-3">‚ûï Additions</p>
              <div className="flex justify-center gap-2">
                {[1, 2, 3, 4, 5].map(n => (
                  <button
                    key={n}
                    onClick={() => toggleAddOp(n)}
                    className={`w-12 h-12 rounded-xl font-bold text-lg transition-all duration-200 ${
                      addOperations.has(n)
                        ? 'bg-gradient-to-br from-green-400 to-emerald-500 text-white shadow-lg scale-110'
                        : 'bg-gray-200 text-gray-400'
                    }`}
                  >
                    +{n}
                  </button>
                ))}
              </div>
            </div>

            {/* Soustractions */}
            <div className="mb-6">
              <p className="text-orange-600 text-center font-bold mb-3">‚ûñ Soustractions</p>
              <div className="flex justify-center gap-2">
                {[1, 2, 3, 4, 5].map(n => (
                  <button
                    key={n}
                    onClick={() => toggleSubOp(n)}
                    className={`w-12 h-12 rounded-xl font-bold text-lg transition-all duration-200 ${
                      subOperations.has(n)
                        ? 'bg-gradient-to-br from-orange-400 to-amber-500 text-white shadow-lg scale-110'
                        : 'bg-gray-200 text-gray-400'
                    }`}
                  >
                    -{n}
                  </button>
                ))}
              </div>
            </div>

            {/* Presets */}
            <div className="mb-6">
              <p className="text-purple-500 text-center font-medium mb-3">üìä Plage de nombres</p>
              <div className="flex gap-2">
                {presets.map(p => (
                  <button
                    key={p.label}
                    onClick={() => { setMin(p.min); setMax(p.max); }}
                    className={`flex-1 py-3 rounded-xl font-medium transition-all ${
                      min === p.min && max === p.max
                        ? 'bg-gradient-to-r from-purple-400 to-pink-400 text-white shadow-lg scale-105'
                        : 'bg-purple-100 text-purple-500 hover:bg-purple-200'
                    }`}
                  >
                    <div className="text-lg">{p.label}</div>
                    <div className="text-xs opacity-75">{p.desc}</div>
                  </button>
                ))}
              </div>
            </div>

            {/* Custom range */}
            <div className="flex gap-4 mb-8">
              <div className="flex-1">
                <label className="text-purple-400 text-sm mb-1 block text-center">De</label>
                <input
                  type="number"
                  value={min}
                  onChange={e => setMin(Math.max(1, parseInt(e.target.value) || 1))}
                  className="w-full py-3 px-4 rounded-xl bg-purple-50 text-purple-700 text-center font-bold text-xl outline-none focus:ring-4 focus:ring-purple-300 border-2 border-purple-200"
                />
              </div>
              <div className="flex-1">
                <label className="text-purple-400 text-sm mb-1 block text-center">√Ä</label>
                <input
                  type="number"
                  value={max}
                  onChange={e => setMax(Math.max(min + 1, parseInt(e.target.value) || min + 1))}
                  className="w-full py-3 px-4 rounded-xl bg-purple-50 text-purple-700 text-center font-bold text-xl outline-none focus:ring-4 focus:ring-purple-300 border-2 border-purple-200"
                />
              </div>
            </div>

            <button
              onClick={() => canStart && onStart({
                addOperations: Array.from(addOperations),
                subOperations: Array.from(subOperations),
                min,
                max
              })}
              disabled={!canStart}
              className={`w-full py-5 rounded-2xl font-bold text-2xl transition-all ${
                canStart
                  ? 'bg-gradient-to-r from-green-400 to-emerald-500 text-white shadow-lg hover:scale-[1.02]'
                  : 'bg-gray-300 text-gray-500 cursor-not-allowed'
              }`}
            >
              üöÄ C'est parti !
            </button>
          </div>
        </div>
      );
    }

    // ========== PUZZLES GALLERY ==========
    function PuzzlesGallery({ puzzleData, onBack, onSelectPuzzle }) {
      return (
        <div className="min-h-screen bg-gradient-to-br from-pink-100 via-purple-100 to-indigo-100 flex items-center justify-center p-4">
          <div className="bg-white/80 backdrop-blur-lg rounded-3xl p-8 w-full max-w-md shadow-2xl border-4 border-purple-300 animate-fade-in">
            <button onClick={onBack} className="text-purple-500 hover:text-purple-700 mb-4 transition text-lg">‚Üê Retour</button>
            <h1 className="text-3xl font-bold text-purple-600 text-center mb-2">üß© Mes Puzzles</h1>
            <p className="text-purple-400 text-center mb-6">
              {puzzleData.puzzles.filter(p => p.completed).length}/{PUZZLES.length} compl√©t√©s
            </p>

            <div className="space-y-4">
              {PUZZLES.map((puzzle, idx) => {
                const data = puzzleData.puzzles[idx];
                const piecesCount = data.pieces.filter(p => p).length;
                const isCurrent = puzzleData.currentPuzzle === idx;
                const isCompleted = data.completed;

                return (
                  <button
                    key={puzzle.id}
                    onClick={() => onSelectPuzzle(idx)}
                    className={`w-full p-4 rounded-2xl transition-all ${
                      isCurrent
                        ? `bg-gradient-to-r ${puzzle.bgColor} ${puzzle.borderColor} border-4 scale-[1.02] shadow-lg`
                        : isCompleted
                        ? `bg-gradient-to-r ${puzzle.bgColor} opacity-90`
                        : 'bg-gray-100 opacity-60'
                    }`}
                  >
                    <div className="flex justify-between items-center mb-3">
                      <span className="font-bold text-lg">{isCompleted ? 'üèÜ' : isCurrent ? '‚ñ∂Ô∏è' : 'üîí'} {puzzle.name}</span>
                      <span className="font-medium">{piecesCount}/9</span>
                    </div>

                    <div className="flex justify-center">
                      <PuzzleGrid puzzle={puzzle} pieces={data.pieces} size="md" />
                    </div>
                  </button>
                );
              })}
            </div>
          </div>
        </div>
      );
    }

    // ========== PUZZLE COMPLETION ANIMATION ==========
    function PuzzleCompleteAnimation({ puzzle, onDismiss }) {
      const allPieces = Array(9).fill(true);

      return (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 animate-fade-in p-4">
          <div className="bg-white rounded-3xl p-8 w-full max-w-sm text-center animate-pop">
            <div className="text-6xl mb-4 animate-celebrate">üéâ</div>
            <h2 className="text-3xl font-bold text-purple-600 mb-4">Puzzle Compl√©t√© !</h2>

            <div className={`bg-gradient-to-r ${puzzle.bgColor} p-4 rounded-2xl mb-6 ${puzzle.borderColor} border-4 flex justify-center`}>
              <PuzzleGrid puzzle={puzzle} pieces={allPieces} size="lg" animate={true} />
            </div>

            <p className="text-gray-600 mb-6">Tu as d√©bloqu√© <strong>{puzzle.name}</strong> !</p>

            <button
              onClick={onDismiss}
              className="w-full py-4 rounded-2xl font-bold text-xl bg-gradient-to-r from-purple-500 to-pink-500 text-white shadow-lg hover:scale-[1.02] transition-all"
            >
              Super ! üåü
            </button>
          </div>
        </div>
      );
    }

    // ========== NEW PIECE ANIMATION ==========
    function NewPieceAnimation({ puzzle, pieceIndices, currentPieces, isPerfect, onDismiss }) {
      // Show puzzle with newly unlocked pieces highlighted
      const piecesWithNew = currentPieces.map((p, i) => p || pieceIndices.includes(i));

      return (
        <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 animate-fade-in p-4">
          <div className="bg-white rounded-3xl p-8 text-center animate-pop">
            {isPerfect && (
              <div className="text-2xl font-bold text-yellow-500 mb-4 animate-pulse-slow">üåü PERFECT ! üåü</div>
            )}

            <h2 className="text-2xl font-bold text-purple-600 mb-4">
              {pieceIndices.length > 1 ? `+${pieceIndices.length} pi√®ces !` : '+1 pi√®ce !'}
            </h2>

            <div className="flex justify-center mb-4">
              <div className="relative">
                <PuzzleGrid puzzle={puzzle} pieces={piecesWithNew} size="md" />
                {/* Highlight new pieces */}
                <div className="absolute inset-0 grid grid-cols-3 grid-rows-3 gap-0.5 pointer-events-none">
                  {Array(9).fill(0).map((_, i) => (
                    <div
                      key={i}
                      className={`${pieceIndices.includes(i) ? 'ring-4 ring-yellow-400 ring-inset animate-pulse-slow rounded-sm' : ''}`}
                    />
                  ))}
                </div>
              </div>
            </div>

            <p className="text-gray-600 mb-6">Puzzle <strong>{puzzle.name}</strong></p>

            <button
              onClick={onDismiss}
              className="px-8 py-3 rounded-xl font-bold text-lg bg-gradient-to-r from-amber-400 to-yellow-500 text-white shadow-lg hover:scale-[1.02] transition-all"
            >
              G√©nial ! ‚ú®
            </button>
          </div>
        </div>
      );
    }

    // Config Screen for Tables (Multiplication & Division)
    function TablesConfig({ mode, onStart, onBack }) {
      const modeInfo = MODES[mode];
      const [selected, setSelected] = useState(new Set([2, 3, 4, 5]));
      const [difficulty, setDifficulty] = useState('normal');
      const [maxTable, setMaxTable] = useState(10);

      const toggle = (n) => {
        if (n > maxTable) return;
        const next = new Set(selected);
        if (next.has(n)) next.delete(n);
        else next.add(n);
        setSelected(next);
      };

      const tables = maxTable === 10 ? [2,3,4,5,6,7,8,9,10] : [2,3,4,5,6,7,8,9,10,11,12];
      const selectAll = () => setSelected(new Set(tables));
      const selectNone = () => setSelected(new Set());

      const handleMaxTableChange = (newMax) => {
        setMaxTable(newMax);
        if (newMax === 10) {
          const next = new Set(selected);
          next.delete(11);
          next.delete(12);
          setSelected(next);
        }
      };

      return (
        <div className="min-h-screen bg-gradient-to-br from-slate-900 via-blue-950 to-slate-900 flex items-center justify-center p-4">
          <div className="bg-white/10 backdrop-blur-lg rounded-3xl p-8 w-full max-w-md shadow-2xl border border-white/20 animate-fade-in">
            <button onClick={onBack} className="text-blue-300 hover:text-white mb-4 transition">‚Üê Retour</button>
            <h1 className="text-2xl font-bold text-white text-center mb-2">{modeInfo.icon} {modeInfo.label}</h1>
            <p className="text-blue-200 text-center mb-6">S√©lectionne les tables</p>

            <div className="flex justify-center gap-2 mb-4">
              <span className="text-blue-300 text-sm">Tables jusqu'√† :</span>
              <button
                onClick={() => handleMaxTableChange(10)}
                className={`px-3 py-1 rounded-lg text-sm font-medium transition-all ${
                  maxTable === 10 ? 'bg-blue-500 text-white' : 'bg-white/10 text-blue-300 hover:bg-white/20'
                }`}
              >10</button>
              <button
                onClick={() => handleMaxTableChange(12)}
                className={`px-3 py-1 rounded-lg text-sm font-medium transition-all ${
                  maxTable === 12 ? 'bg-blue-500 text-white' : 'bg-white/10 text-blue-300 hover:bg-white/20'
                }`}
              >12</button>
            </div>

            <div className="flex justify-center gap-2 mb-4">
              <button onClick={selectAll} className="text-sm text-blue-300 hover:text-white transition">Tout</button>
              <span className="text-blue-500">|</span>
              <button onClick={selectNone} className="text-sm text-blue-300 hover:text-white transition">Aucun</button>
            </div>

            <div className={`grid gap-3 mb-6 ${maxTable === 10 ? 'grid-cols-3' : 'grid-cols-4'}`}>
              {tables.map(n => (
                <button
                  key={n}
                  onClick={() => toggle(n)}
                  className={`aspect-square rounded-xl font-bold text-lg transition-all duration-200 ${
                    selected.has(n)
                      ? "bg-blue-500 text-white shadow-lg shadow-blue-500/50 scale-105"
                      : "bg-white/10 text-blue-200 hover:bg-white/20"
                  }`}
                >
                  {n}
                </button>
              ))}
            </div>

            <DifficultySelector difficulty={difficulty} setDifficulty={setDifficulty} />

            <button
              onClick={() => selected.size > 0 && onStart({ tables: Array.from(selected), maxTable }, difficulty)}
              disabled={selected.size === 0}
              className={`w-full py-4 rounded-2xl font-bold text-lg transition-all duration-300 ${
                selected.size > 0
                  ? `bg-gradient-to-r ${modeInfo.color} text-white shadow-lg hover:scale-[1.02]`
                  : "bg-white/10 text-white/30 cursor-not-allowed"
              }`}
            >
              C'est parti ! ‚Üí
            </button>
          </div>
        </div>
      );
    }

    // Config Screen for Addition/Subtraction
    function RangeConfig({ mode, onStart, onBack }) {
      const modeInfo = MODES[mode];
      const [min, setMin] = useState(1);
      const [max, setMax] = useState(20);
      const [difficulty, setDifficulty] = useState('normal');

      const presets = [
        { label: "1-20", min: 1, max: 20 },
        { label: "1-50", min: 1, max: 50 },
        { label: "1-100", min: 1, max: 100 },
      ];

      const isValid = min >= 0 && max > min;

      return (
        <div className="min-h-screen bg-gradient-to-br from-slate-900 via-blue-950 to-slate-900 flex items-center justify-center p-4">
          <div className="bg-white/10 backdrop-blur-lg rounded-3xl p-8 w-full max-w-md shadow-2xl border border-white/20 animate-fade-in">
            <button onClick={onBack} className="text-blue-300 hover:text-white mb-4 transition">‚Üê Retour</button>
            <h1 className="text-2xl font-bold text-white text-center mb-2">{modeInfo.icon} {modeInfo.label}</h1>
            <p className="text-blue-200 text-center mb-6">Configure la plage de nombres</p>

            <div className="flex gap-2 mb-6">
              {presets.map(p => (
                <button
                  key={p.label}
                  onClick={() => { setMin(p.min); setMax(p.max); }}
                  className={`flex-1 py-2 rounded-xl font-medium text-sm transition-all ${
                    min === p.min && max === p.max
                      ? `bg-gradient-to-r ${modeInfo.color} text-white shadow-lg`
                      : "bg-white/10 text-blue-200 hover:bg-white/20"
                  }`}
                >
                  {p.label}
                </button>
              ))}
            </div>

            <div className="flex gap-4 mb-6">
              <div className="flex-1">
                <label className="text-blue-300 text-sm mb-1 block">Min</label>
                <input
                  type="number"
                  value={min}
                  onChange={e => setMin(Math.max(0, parseInt(e.target.value) || 0))}
                  className="w-full py-3 px-4 rounded-xl bg-white/10 text-white text-center font-bold outline-none focus:ring-2 focus:ring-blue-500"
                />
              </div>
              <div className="flex-1">
                <label className="text-blue-300 text-sm mb-1 block">Max</label>
                <input
                  type="number"
                  value={max}
                  onChange={e => setMax(parseInt(e.target.value) || 0)}
                  className="w-full py-3 px-4 rounded-xl bg-white/10 text-white text-center font-bold outline-none focus:ring-2 focus:ring-blue-500"
                />
              </div>
            </div>

            <DifficultySelector difficulty={difficulty} setDifficulty={setDifficulty} />

            <button
              onClick={() => isValid && onStart({ min, max }, difficulty)}
              disabled={!isValid}
              className={`w-full py-4 rounded-2xl font-bold text-lg transition-all duration-300 ${
                isValid
                  ? `bg-gradient-to-r ${modeInfo.color} text-white shadow-lg hover:scale-[1.02]`
                  : "bg-white/10 text-white/30 cursor-not-allowed"
              }`}
            >
              C'est parti ! ‚Üí
            </button>
          </div>
        </div>
      );
    }

    // Kids Quiz Screen
    function KidsQuizScreen({ questions, onFinish, onMenu }) {
      const [index, setIndex] = useState(0);
      const [answer, setAnswer] = useState("");
      const [results, setResults] = useState([]);
      const [feedback, setFeedback] = useState(null);
      const [feedbackText, setFeedbackText] = useState("");
      const [streak, setStreak] = useState(0);
      const [maxStreak, setMaxStreak] = useState(0);
      const inputRef = useRef(null);
      const feedbackRef = useRef(false);

      const current = questions[index];

      // Dev: triple $ = instant win
      const cheatRef = useRef({ count: 0, timer: null });
      useEffect(() => {
        const handleCheat = (e) => {
          if (e.key === '$') {
            cheatRef.current.count++;
            clearTimeout(cheatRef.current.timer);
            if (cheatRef.current.count >= 3) {
              cheatRef.current.count = 0;
              const remaining = questions.slice(index).map(q => ({ ...q, userAnswer: q.answer, correct: true }));
              onFinish([...results, ...remaining], results.length + remaining.length);
            } else {
              cheatRef.current.timer = setTimeout(() => { cheatRef.current.count = 0; }, 500);
            }
          }
        };
        window.addEventListener('keydown', handleCheat);
        return () => { window.removeEventListener('keydown', handleCheat); clearTimeout(cheatRef.current.timer); };
      }, [index, results, questions, onFinish]);

      const nextQuestion = (newStreak, newMaxStreak) => {
        if (index + 1 >= questions.length) {
          const finalResult = { ...current, userAnswer: parseInt(answer) || null, correct: parseInt(answer) === current.answer };
          onFinish([...results, finalResult], newMaxStreak);
        } else {
          setIndex(i => i + 1);
          setAnswer("");
          setFeedback(null);
          feedbackRef.current = false;
        }
      };

      const handleSubmit = () => {
        if (feedbackRef.current || !answer) return;
        feedbackRef.current = true;
        const isCorrect = parseInt(answer) === current.answer;
        setFeedback(isCorrect ? 'correct' : 'wrong');

        const texts = isCorrect ? KIDS_FEEDBACK.correct : KIDS_FEEDBACK.wrong;
        setFeedbackText(texts[Math.floor(Math.random() * texts.length)]);

        let newStreak = streak;
        let newMaxStreak = maxStreak;
        if (isCorrect) {
          newStreak = streak + 1;
          newMaxStreak = Math.max(maxStreak, newStreak);
          setStreak(newStreak);
          setMaxStreak(newMaxStreak);
        } else {
          setStreak(0);
        }

        setResults(r => [...r, { ...current, userAnswer: parseInt(answer), correct: isCorrect }]);
        setTimeout(() => nextQuestion(isCorrect ? newStreak : 0, newMaxStreak), 2000);
      };

      useEffect(() => {
        if (!feedbackRef.current && inputRef.current) {
          inputRef.current.focus();
          setTimeout(() => {
            inputRef.current?.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }, 300);
        }
      }, [index, feedback]);

      return (
        <div className="min-h-screen bg-gradient-to-br from-pink-100 via-purple-100 to-indigo-100 flex items-center justify-center p-4">
          <div className="bg-white/80 backdrop-blur-lg rounded-3xl p-8 w-full max-w-md shadow-2xl border-4 border-purple-300 animate-fade-in">

            <div className="flex justify-between items-center mb-6">
              <button onClick={onMenu} className="text-purple-400 hover:text-purple-600 text-lg transition">‚úï</button>
              {streak >= 2 && (
                <span className="text-amber-500 font-bold text-xl flex items-center gap-1 animate-pulse-slow">
                  ‚≠ê {streak}
                </span>
              )}
              <span className="text-purple-500 font-bold text-lg">{index + 1} / {questions.length}</span>
            </div>

            <div className="flex justify-center gap-2 mb-6">
              {results.map((r, i) => (
                <div key={i} className={`w-4 h-4 rounded-full ${r.correct ? 'bg-green-400' : 'bg-red-400'}`} />
              ))}
              {Array(questions.length - results.length).fill(0).map((_, i) => (
                <div key={`empty-${i}`} className="w-4 h-4 rounded-full bg-purple-200" />
              ))}
            </div>

            <div className={`text-center mb-8 transition-all duration-300 ${feedback === 'correct' ? 'scale-110' : feedback === 'wrong' ? 'animate-shake' : ''}`}>
              <div className="text-7xl font-bold text-purple-600 mb-2">
                {current.a} {current.op} {current.b}
              </div>
              <div className="text-4xl text-purple-400">= ?</div>
            </div>

            {feedback && (
              <div className={`text-center mb-6 animate-pop`}>
                <div className={`text-3xl font-bold ${feedback === 'correct' ? 'text-green-500' : 'text-orange-500'}`}>
                  {feedbackText}
                </div>
                {feedback === 'wrong' && (
                  <div className="text-xl text-purple-500 mt-2">
                    C'√©tait <span className="font-bold text-purple-700">{current.answer}</span>
                  </div>
                )}
              </div>
            )}

            {!feedback && (
              <div>
                <input
                  ref={inputRef}
                  type="text"
                  inputMode="numeric"
                  pattern="[0-9]*"
                  value={answer}
                  onChange={e => setAnswer(e.target.value.replace(/[^0-9]/g, ''))}
                  onKeyDown={e => { if (e.key === 'Enter' && answer) handleSubmit(); }}
                  onFocus={e => setTimeout(() => e.target.scrollIntoView({ behavior: 'smooth', block: 'center' }), 300)}
                  className="w-full text-center text-6xl font-bold py-6 rounded-3xl outline-none bg-purple-50 text-purple-700 border-4 border-purple-300 focus:border-purple-500 focus:ring-4 focus:ring-purple-200 transition-all"
                  placeholder="?"
                  autoComplete="off"
                />

                <button
                  onClick={handleSubmit}
                  disabled={!answer}
                  className={`w-full mt-6 py-5 rounded-2xl font-bold text-2xl transition-all ${
                    answer
                      ? 'bg-gradient-to-r from-green-400 to-emerald-500 text-white shadow-lg hover:scale-[1.02]'
                      : 'bg-gray-200 text-gray-400 cursor-not-allowed'
                  }`}
                >
                  ‚úì Valider
                </button>
              </div>
            )}
          </div>
        </div>
      );
    }

    // Kids Result Screen
    function KidsResultScreen({ results, puzzleData, earnedPiece, newPieceIndex, puzzleJustCompleted, completedPuzzleIdx, onRestart, onMenu, onDismissAnimation }) {
      const correctCount = results.filter(r => r.correct).length;
      const percent = Math.round((correctCount / results.length) * 100);

      const getMessage = () => {
        if (percent === 100) return { emoji: "üèÜ", text: "PARFAIT !", color: "text-yellow-500" };
        if (percent >= 80) return { emoji: "üåü", text: "Super travail !", color: "text-green-500" };
        if (percent >= 60) return { emoji: "üëç", text: "Bien jou√© !", color: "text-blue-500" };
        if (percent >= 40) return { emoji: "üí™", text: "Continue !", color: "text-purple-500" };
        return { emoji: "üåà", text: "Tu vas y arriver !", color: "text-pink-500" };
      };

      const msg = getMessage();
      const stars = Math.ceil((correctCount / results.length) * 5);
      // Pour l'affichage normal, utiliser le puzzle actuel
      const currentPuzzle = PUZZLES[puzzleData.currentPuzzle];
      const piecesCount = puzzleData.puzzles[puzzleData.currentPuzzle].pieces.filter(p => p).length;
      // Pour les animations, utiliser le puzzle qui a √©t√© travaill√© (avant le changement)
      const animatedPuzzle = PUZZLES[completedPuzzleIdx ?? puzzleData.currentPuzzle];
      const animatedPuzzlePieces = puzzleData.puzzles[completedPuzzleIdx ?? puzzleData.currentPuzzle].pieces;

      return (
        <div className="min-h-screen bg-gradient-to-br from-pink-100 via-purple-100 to-indigo-100 flex items-center justify-center p-4">
          {/* Confetti pour les perfect ! */}
          {percent === 100 && <Confetti count={60} />}

          <div className="bg-white/80 backdrop-blur-lg rounded-3xl p-8 w-full max-w-md shadow-2xl border-4 border-purple-300 animate-fade-in text-center">

            <div className="text-8xl mb-4 animate-pop">{msg.emoji}</div>

            <div className="flex justify-center gap-2 mb-4">
              {[1,2,3,4,5].map(i => (
                <span
                  key={i}
                  className={`text-4xl ${i <= stars ? 'animate-star-pop' : 'opacity-30'}`}
                  style={i <= stars ? { animationDelay: `${(i - 1) * 0.15}s` } : {}}
                >
                  {i <= stars ? '‚≠ê' : '‚òÜ'}
                </span>
              ))}
            </div>

            <div className={`text-4xl font-bold mb-2 ${msg.color}`}>{msg.text}</div>
            <div className="text-2xl text-purple-500 mb-4">
              {correctCount} / {results.length} bonnes r√©ponses
            </div>

            {/* Puzzle progress */}
            <div className="bg-gradient-to-r from-amber-50 to-yellow-50 rounded-2xl p-4 mb-6 border-2 border-amber-200">
              <div className="flex justify-between items-center mb-3">
                <span className="text-amber-700 font-medium">üß© {currentPuzzle.name}</span>
                <span className="text-amber-600 font-bold">{piecesCount}/9</span>
              </div>
              <div className="flex justify-center mb-3">
                <PuzzleGrid
                  puzzle={currentPuzzle}
                  pieces={puzzleData.puzzles[puzzleData.currentPuzzle].pieces}
                  size="sm"
                />
              </div>
              {earnedPiece && newPieceIndex.length > 0 ? (
                <div className="text-green-600 font-bold text-center">
                  +{newPieceIndex.length} pi√®ce{newPieceIndex.length > 1 ? 's' : ''} ! {percent === 100 ? 'üåü' : '‚ú®'}
                </div>
              ) : percent < 70 ? (
                <div className="text-gray-500 text-sm text-center">‚â•70% = 1 pi√®ce ¬∑ 100% = 2 pi√®ces</div>
              ) : (
                <div className="text-amber-600 text-sm text-center">Puzzle complet ! üéâ</div>
              )}
            </div>

            <div className="bg-purple-50 rounded-2xl p-4 mb-6 max-h-32 overflow-y-auto">
              {results.map((r, i) => (
                <div key={i} className={`flex justify-between items-center py-1 text-lg ${r.correct ? 'text-green-600' : 'text-red-500'}`}>
                  <span>{r.a} {r.op} {r.b} = {r.answer}</span>
                  <span>{r.correct ? '‚úì' : '‚úó'}</span>
                </div>
              ))}
            </div>

            <div className="space-y-3">
              <button
                onClick={onRestart}
                className="w-full py-5 rounded-2xl font-bold text-2xl bg-gradient-to-r from-green-400 to-emerald-500 text-white shadow-lg hover:scale-[1.02] transition-all"
              >
                üîÑ Rejouer
              </button>
              <button
                onClick={onMenu}
                className="w-full py-4 rounded-2xl font-bold text-lg bg-purple-100 text-purple-600 hover:bg-purple-200 transition-all"
              >
                ‚Üê Menu
              </button>
            </div>
          </div>

          {/* Animations */}
          {earnedPiece && !puzzleJustCompleted && newPieceIndex.length > 0 && (
            <NewPieceAnimation
              puzzle={animatedPuzzle}
              pieceIndices={newPieceIndex}
              currentPieces={animatedPuzzlePieces}
              isPerfect={percent === 100}
              onDismiss={onDismissAnimation}
            />
          )}
          {puzzleJustCompleted && (
            <PuzzleCompleteAnimation
              puzzle={animatedPuzzle}
              onDismiss={onDismissAnimation}
            />
          )}
        </div>
      );
    }

    // Shared Difficulty Selector
    function DifficultySelector({ difficulty, setDifficulty }) {
      return (
        <div className="mb-8">
          <p className="text-blue-200 text-center text-sm mb-3">Difficult√©</p>
          <div className="flex gap-2">
            {Object.entries(DIFFICULTY).map(([key, val]) => (
              <button
                key={key}
                onClick={() => setDifficulty(key)}
                className={`flex-1 py-3 rounded-xl font-medium text-sm transition-all duration-200 ${
                  difficulty === key
                    ? `bg-gradient-to-r ${val.color} text-white shadow-lg scale-105`
                    : "bg-white/10 text-blue-200 hover:bg-white/20"
                }`}
              >
                <div>{val.label}</div>
                <div className="text-xs opacity-75">{val.timer === 0 ? '‚àû' : val.timer + 's'} ¬∑ x{val.multiplier}</div>
              </button>
            ))}
          </div>
        </div>
      );
    }

    // Quiz Screen
    function QuizScreen({ mode, questions, difficulty, onFinish, onMenu }) {
      const modeInfo = MODES[mode];
      const config = DIFFICULTY[difficulty];
      const [index, setIndex] = useState(0);
      const [answer, setAnswer] = useState("");
      const [timer, setTimer] = useState(config.timer);
      const [results, setResults] = useState([]);
      const [feedback, setFeedback] = useState(null);
      const [streak, setStreak] = useState(0);
      const [maxStreak, setMaxStreak] = useState(0);
      const inputRef = useRef(null);
      const feedbackRef = useRef(false);
      const answerRef = useRef("");

      const current = questions[index];

      // Dev: triple $ = instant win
      const cheatRef = useRef({ count: 0, timer: null });
      useEffect(() => {
        const handleCheat = (e) => {
          if (e.key === '$') {
            cheatRef.current.count++;
            clearTimeout(cheatRef.current.timer);
            if (cheatRef.current.count >= 3) {
              cheatRef.current.count = 0;
              const remaining = questions.slice(index).map(q => ({ ...q, userAnswer: q.answer, correct: true }));
              onFinish([...results, ...remaining], results.length + remaining.length);
            } else {
              cheatRef.current.timer = setTimeout(() => { cheatRef.current.count = 0; }, 500);
            }
          }
        };
        window.addEventListener('keydown', handleCheat);
        return () => { window.removeEventListener('keydown', handleCheat); clearTimeout(cheatRef.current.timer); };
      }, [index, results, questions, onFinish]);

      useEffect(() => {
        answerRef.current = answer;
      }, [answer]);

      const nextQuestion = (newStreak, newMaxStreak) => {
        if (index + 1 >= questions.length) {
          const finalResult = { ...current, userAnswer: parseInt(answer) || null, correct: parseInt(answer) === current.answer };
          onFinish([...results, finalResult], newMaxStreak);
        } else {
          setIndex(i => i + 1);
          setAnswer("");
          setTimer(config.timer);
          setFeedback(null);
          feedbackRef.current = false;
        }
      };

      const handleTimeout = () => {
        if (feedbackRef.current) return;
        feedbackRef.current = true;

        const currentAnswer = answerRef.current;

        if (currentAnswer) {
          const isCorrect = parseInt(currentAnswer) === current.answer;
          setFeedback(isCorrect ? 'correct' : 'wrong');

          let newStreak = streak;
          let newMaxStreak = maxStreak;
          if (isCorrect) {
            newStreak = streak + 1;
            newMaxStreak = Math.max(maxStreak, newStreak);
            setStreak(newStreak);
            setMaxStreak(newMaxStreak);
          } else {
            setStreak(0);
          }

          setResults(r => [...r, { ...current, userAnswer: parseInt(currentAnswer), correct: isCorrect }]);
          setTimeout(() => nextQuestion(isCorrect ? newStreak : 0, newMaxStreak), 1200);
        } else {
          setFeedback('wrong');
          setStreak(0);
          setResults(r => [...r, { ...current, userAnswer: null, correct: false }]);
          setTimeout(() => nextQuestion(0, maxStreak), 1200);
        }
      };

      const handleSubmit = () => {
        if (feedbackRef.current || !answer) return;
        feedbackRef.current = true;
        const isCorrect = parseInt(answer) === current.answer;
        setFeedback(isCorrect ? 'correct' : 'wrong');

        let newStreak = streak;
        let newMaxStreak = maxStreak;
        if (isCorrect) {
          newStreak = streak + 1;
          newMaxStreak = Math.max(maxStreak, newStreak);
          setStreak(newStreak);
          setMaxStreak(newMaxStreak);
        } else {
          setStreak(0);
        }

        setResults(r => [...r, { ...current, userAnswer: parseInt(answer), correct: isCorrect }]);
        setTimeout(() => nextQuestion(newStreak, newMaxStreak), 1200);
      };

      useEffect(() => {
        if (feedbackRef.current || config.timer === 0) return;
        const interval = setInterval(() => {
          setTimer(t => {
            if (t <= 1) {
              handleTimeout();
              return config.timer;
            }
            return t - 1;
          });
        }, 1000);
        return () => clearInterval(interval);
      }, [index]);

      useEffect(() => {
        if (!feedbackRef.current && inputRef.current) {
          inputRef.current.focus();
          setTimeout(() => {
            inputRef.current?.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }, 300);
        }
      }, [index, feedback]);

      const timerPercent = (timer / config.timer) * 100;
      const timerColor = timer <= 3 ? "bg-red-500" : timer <= 5 ? "bg-yellow-500" : "bg-green-500";

      return (
        <div className="min-h-screen bg-gradient-to-br from-slate-900 via-blue-950 to-slate-900 flex items-center justify-center p-4">
          <div className="bg-white/10 backdrop-blur-lg rounded-3xl p-8 w-full max-w-md shadow-2xl border border-white/20 animate-fade-in">
            <div className="flex justify-between items-center mb-4">
              <button onClick={onMenu} className="text-blue-400 hover:text-white text-sm transition">‚úï Quitter</button>
              {streak >= 2 && (
                <span className="text-amber-400 font-bold text-sm flex items-center gap-1 animate-pulse-slow">
                  üî• {streak}
                </span>
              )}
              <span className="text-blue-300 font-medium">{index + 1} / {questions.length}</span>
              <div className="flex gap-1">
                {results.map((r, i) => (
                  <div key={i} className={`w-2 h-2 rounded-full ${r.correct ? 'bg-green-400' : 'bg-red-400'}`} />
                ))}
                {Array(questions.length - results.length).fill(0).map((_, i) => (
                  <div key={`empty-${i}`} className="w-2 h-2 rounded-full bg-white/20" />
                ))}
              </div>
            </div>

            {config.timer > 0 ? (
              <div className="h-2 bg-white/10 rounded-full mb-8 overflow-hidden">
                <div className={`h-full ${timerColor} transition-all duration-1000 ease-linear`} style={{ width: `${timerPercent}%` }} />
              </div>
            ) : (
              <div className="flex justify-center mb-6">
                <span className="text-blue-400 text-sm bg-blue-500/10 px-3 py-1 rounded-full">Mode Zen ‚Äî sans limite de temps</span>
              </div>
            )}

            <div className={`text-center mb-8 transition-all duration-300 ${feedback === 'correct' ? 'scale-105' : feedback === 'wrong' ? 'animate-shake' : ''}`}>
              <div className="text-5xl font-bold text-white mb-2">
                {current.a} {modeInfo.symbol} {current.b}
              </div>
              <div className="text-2xl text-blue-300">= ?</div>
            </div>

            <div>
              <input
                ref={inputRef}
                type="text"
                inputMode="numeric"
                pattern="[0-9-]*"
                value={answer}
                onChange={e => setAnswer(e.target.value.replace(/[^0-9-]/g, ''))}
                onKeyDown={e => { if (e.key === 'Enter' && answer && !feedback) handleSubmit(); }}
                onFocus={e => setTimeout(() => e.target.scrollIntoView({ behavior: 'smooth', block: 'center' }), 300)}
                disabled={!!feedback}
                className={`w-full text-center text-4xl font-bold py-4 rounded-2xl outline-none transition-all duration-300 ${
                  feedback === 'correct'
                    ? 'bg-green-500/30 text-green-300 border-2 border-green-500'
                    : feedback === 'wrong'
                    ? 'bg-red-500/30 text-red-300 border-2 border-red-500'
                    : 'bg-white/10 text-white border-2 border-transparent focus:border-blue-500'
                }`}
                placeholder="?"
                autoComplete="off"
              />

              {feedback && (
                <div className={`text-center mt-4 text-xl font-bold ${feedback === 'correct' ? 'text-green-400' : 'text-red-400'}`}>
                  {feedback === 'correct' ? '‚úì Correct !' : `‚úó C'√©tait ${current.answer}`}
                </div>
              )}

              {!feedback && (
                <button
                  onClick={handleSubmit}
                  disabled={!answer}
                  className={`w-full mt-6 py-4 rounded-2xl font-bold text-lg transition-all ${
                    answer
                      ? `bg-gradient-to-r ${modeInfo.color} text-white hover:shadow-lg`
                      : 'bg-white/10 text-white/30 cursor-not-allowed'
                  }`}
                >
                  Valider
                </button>
              )}
            </div>
          </div>
        </div>
      );
    }

    // Result Screen
    function ResultScreen({ mode, results, difficulty, newAchievements, onRestart, onConfig, onMenu }) {
      const modeInfo = MODES[mode];
      const diffConfig = DIFFICULTY[difficulty];
      const correctCount = results.filter(r => r.correct).length;
      const score = Math.round(correctCount * diffConfig.multiplier * 10);
      const percent = Math.round((correctCount / results.length) * 100);

      const getMessage = () => {
        if (percent === 100) return { emoji: "üèÜ", text: "Parfait !" };
        if (percent >= 80) return { emoji: "üî•", text: "Excellent !" };
        if (percent >= 60) return { emoji: "üí™", text: "Pas mal !" };
        if (percent >= 40) return { emoji: "üìö", text: "Continue !" };
        return { emoji: "üéØ", text: "√Ä retravailler" };
      };

      const msg = getMessage();

      return (
        <div className="min-h-screen bg-gradient-to-br from-slate-900 via-blue-950 to-slate-900 flex items-center justify-center p-4">
          {/* Confetti pour les perfect ! */}
          {percent === 100 && <Confetti count={50} />}

          <div className="bg-white/10 backdrop-blur-lg rounded-3xl p-8 w-full max-w-md shadow-2xl border border-white/20 animate-fade-in">
            <div className="text-center mb-6">
              <div className="text-6xl mb-4 animate-pop">{msg.emoji}</div>
              <div className="text-5xl font-bold text-white mb-1">+{score} pts</div>
              <div className="text-lg text-blue-300 mb-1">{correctCount}/{results.length} ¬∑ {diffConfig.label} (x{diffConfig.multiplier})</div>
              <div className="text-xl text-blue-200">{msg.text}</div>
            </div>

            {newAchievements.length > 0 && (
              <div className="bg-gradient-to-r from-amber-500/20 to-yellow-500/20 rounded-2xl p-4 mb-6 border border-amber-500/30 animate-pop">
                <div className="text-amber-300 font-bold text-center mb-3">üéâ {newAchievements.length > 1 ? 'Nouveaux badges !' : 'Nouveau badge !'}</div>
                <div className="flex justify-center gap-4">
                  {newAchievements.map(key => {
                    const ach = ACHIEVEMENTS[key];
                    return (
                      <div key={key} className="text-center">
                        <div className="text-3xl mb-1 animate-pulse-slow">{ach.icon}</div>
                        <div className="text-white font-medium text-sm">{ach.name}</div>
                      </div>
                    );
                  })}
                </div>
              </div>
            )}

            <div className="bg-white/5 rounded-2xl p-4 mb-6 max-h-40 overflow-y-auto">
              {results.map((r, i) => (
                <div key={i} className={`flex justify-between items-center py-2 ${i > 0 ? 'border-t border-white/10' : ''}`}>
                  <span className="text-blue-200">{r.a} {modeInfo.symbol} {r.b} = {r.answer}</span>
                  <span className={r.correct ? 'text-green-400' : 'text-red-400'}>
                    {r.correct ? '‚úì' : `‚úó ${r.userAnswer ?? '‚Äî'}`}
                  </span>
                </div>
              ))}
            </div>

            <div className="space-y-3">
              <button
                onClick={onRestart}
                className={`w-full py-4 rounded-2xl font-bold text-lg bg-gradient-to-r ${modeInfo.color} text-white hover:shadow-lg transition-all`}
              >
                Rejouer ‚Üª
              </button>
              <button
                onClick={onConfig}
                className="w-full py-3 rounded-2xl font-medium text-blue-300 bg-white/10 hover:bg-white/20 transition-all"
              >
                Modifier les param√®tres
              </button>
              <button
                onClick={onMenu}
                className="w-full py-3 rounded-2xl font-medium text-blue-400 hover:text-white transition-all"
              >
                ‚Üê Menu principal
              </button>
            </div>
          </div>
        </div>
      );
    }

    // Main App
    function App() {
      const [screen, setScreen] = useState('home');
      const [mode, setMode] = useState(null);
      const [gameConfig, setGameConfig] = useState(null);
      const [difficulty, setDifficulty] = useState('normal');
      const [questions, setQuestions] = useState([]);
      const [results, setResults] = useState([]);
      const [stats, setStats] = useState(loadStats);
      const [newAchievements, setNewAchievements] = useState([]);
      const [currentStreak, setCurrentStreak] = useState(0);
      const [puzzleData, setPuzzleData] = useState(loadPuzzles);
      const [earnedPiece, setEarnedPiece] = useState(false);
      const [newPieceIndex, setNewPieceIndex] = useState(null);
      const [puzzleJustCompleted, setPuzzleJustCompleted] = useState(false);
      const [completedPuzzleIdx, setCompletedPuzzleIdx] = useState(null);
      const [showAnimation, setShowAnimation] = useState(false);

      // Navigation
      const goHome = () => { setScreen('home'); setMode(null); setNewAchievements([]); setEarnedPiece(false); setPuzzleJustCompleted(false); };
      const goKidsMenu = () => setScreen('kids-menu');
      const goAdvancedMenu = () => setScreen('menu');
      const goStats = () => setScreen('stats');
      const goPuzzles = () => setScreen('puzzles');
      const goKidsConfig = () => setScreen('kids-config');

      // Breakout game
      const [breakoutLives, setBreakoutLives] = useState(0);
      const goBreakout = () => {
        const totalLives = puzzleData.puzzles.reduce((sum, p) => sum + (p.lives || 0), 0);
        if (totalLives > 0) {
          setBreakoutLives(totalLives);
          setScreen('breakout');
        }
      };
      const grantCheatLives = (amount) => {
        const newPuzzles = JSON.parse(JSON.stringify(puzzleData));
        newPuzzles.puzzles[0].lives = (newPuzzles.puzzles[0].lives || 0) + amount;
        setPuzzleData(newPuzzles);
        savePuzzleData(newPuzzles);
      };
      const loseBreakoutLife = () => {
        // Find first puzzle with lives and decrement
        const newPuzzles = JSON.parse(JSON.stringify(puzzleData));
        for (let p of newPuzzles.puzzles) {
          if (p.lives > 0) {
            p.lives--;
            break;
          }
        }
        setPuzzleData(newPuzzles);
        savePuzzles(newPuzzles);
      };
      const exitBreakout = () => setScreen('kids-menu');

      const selectMode = (selectedMode) => {
        setMode(selectedMode);
        setScreen('config');
      };

      const startQuiz = (config, selectedDifficulty) => {
        setGameConfig(config);
        setDifficulty(selectedDifficulty);
        setQuestions(generateQuestions(mode, config));
        setResults([]);
        setCurrentStreak(0);
        setScreen('quiz');
      };

      const finishQuiz = (quizResults, maxStreak) => {
        const correctCount = quizResults.filter(r => r.correct).length;
        const diffConfig = DIFFICULTY[difficulty];
        const score = Math.round(correctCount * diffConfig.multiplier * 10);
        const isPerfect = correctCount === quizResults.length;

        const gameData = {
          results: quizResults,
          difficulty,
          currentStreak: maxStreak,
        };
        const unlocked = checkAchievements(stats, gameData);
        setNewAchievements(unlocked);

        const newStats = {
          ...stats,
          totalScore: stats.totalScore + score,
          gamesPlayed: stats.gamesPlayed + 1,
          perfectGames: stats.perfectGames + (isPerfect ? 1 : 0),
          bestStreak: Math.max(stats.bestStreak, maxStreak),
          totalCorrect: stats.totalCorrect + correctCount,
          totalQuestions: stats.totalQuestions + quizResults.length,
          achievements: [...stats.achievements, ...unlocked],
        };

        setStats(newStats);
        saveStats(newStats);
        setResults(quizResults);
        setScreen('result');
      };

      const restart = () => {
        setQuestions(generateQuestions(mode, gameConfig));
        setResults([]);
        setCurrentStreak(0);
        setNewAchievements([]);
        setScreen('quiz');
      };

      const goConfig = () => setScreen('config');
      const goMenu = () => { setScreen('menu'); setMode(null); setNewAchievements([]); };

      // Kids mode
      const startKidsQuiz = (config) => {
        setGameConfig(config);
        setMode('kids');
        setDifficulty('zen');
        setQuestions(generateQuestions('kids', config));
        setResults([]);
        setCurrentStreak(0);
        setEarnedPiece(false);
        setNewPieceIndex(null);
        setPuzzleJustCompleted(false);
        setScreen('kids-quiz');
      };

      const finishKidsQuiz = (quizResults, maxStreak) => {
        const correctCount = quizResults.filter(r => r.correct).length;
        const percent = Math.round((correctCount / quizResults.length) * 100);
        const score = correctCount * 5;
        const isPerfect = percent === 100;

        // Check if earned puzzle pieces (‚â•70% = 1 piece, 100% = 2 pieces)
        let piecesEarned = 0;
        let pieceIndices = [];
        let justCompleted = false;

        if (percent >= 70) {
          const piecesToEarn = isPerfect ? 2 : 1;
          const currentPuzzleIdx = puzzleData.currentPuzzle;
          const currentPuzzlePieces = [...puzzleData.puzzles[currentPuzzleIdx].pieces];

          // Find missing pieces
          for (let i = 0; i < piecesToEarn; i++) {
            const missingIdx = currentPuzzlePieces.findIndex(p => !p);
            if (missingIdx !== -1) {
              currentPuzzlePieces[missingIdx] = true;
              pieceIndices.push(missingIdx);
              piecesEarned++;
            }
          }

          if (piecesEarned > 0) {
            // Update puzzle data
            const newPuzzles = JSON.parse(JSON.stringify(puzzleData));
            newPuzzles.puzzles[currentPuzzleIdx].pieces = currentPuzzlePieces;

            // Check if puzzle just completed
            const allPiecesNow = currentPuzzlePieces.every(p => p);
            if (allPiecesNow) {
              newPuzzles.puzzles[currentPuzzleIdx].completed = true;
              newPuzzles.puzzles[currentPuzzleIdx].lives = 5; // Gain 5 lives for breakout game!
              justCompleted = true;

              // Move to next incomplete puzzle
              const nextIncomplete = newPuzzles.puzzles.findIndex((p, i) => i !== currentPuzzleIdx && !p.completed);
              if (nextIncomplete !== -1) {
                newPuzzles.currentPuzzle = nextIncomplete;
              }
            }

            setPuzzleData(newPuzzles);
            savePuzzles(newPuzzles);
          }
        }

        setEarnedPiece(piecesEarned > 0);
        setNewPieceIndex(pieceIndices);
        setPuzzleJustCompleted(justCompleted);
        setCompletedPuzzleIdx(puzzleData.currentPuzzle); // Garder l'index du puzzle actuel AVANT le changement
        setShowAnimation(piecesEarned > 0);

        // Update stats
        const newStats = {
          ...stats,
          totalScore: stats.totalScore + score,
          gamesPlayed: stats.gamesPlayed + 1,
          perfectGames: stats.perfectGames + (correctCount === quizResults.length ? 1 : 0),
          bestStreak: Math.max(stats.bestStreak, maxStreak),
          totalCorrect: stats.totalCorrect + correctCount,
          totalQuestions: stats.totalQuestions + quizResults.length,
        };

        setStats(newStats);
        saveStats(newStats);
        setResults(quizResults);
        setScreen('kids-result');
      };

      const restartKids = () => {
        setQuestions(generateQuestions('kids', gameConfig));
        setResults([]);
        setCurrentStreak(0);
        setEarnedPiece(false);
        setNewPieceIndex(null);
        setPuzzleJustCompleted(false);
        setScreen('kids-quiz');
      };

      const dismissAnimation = () => {
        setShowAnimation(false);
        setEarnedPiece(false);
        setPuzzleJustCompleted(false);
      };

      const selectPuzzle = (idx) => {
        if (!puzzleData.puzzles[idx].completed || puzzleData.currentPuzzle === idx) {
          const newData = { ...puzzleData, currentPuzzle: idx };
          setPuzzleData(newData);
          savePuzzles(newData);
        }
      };

      const resetStats = () => {
        if (confirm('R√©initialiser toutes les statistiques ?')) {
          setStats(defaultStats);
          saveStats(defaultStats);
        }
      };

      const resetPuzzles = () => {
        if (confirm('R√©initialiser tous les puzzles ?')) {
          setPuzzleData(defaultPuzzles);
          savePuzzles(defaultPuzzles);
        }
      };

      // Render
      if (screen === 'home') return <HomeScreen onKids={goKidsMenu} onAdvanced={goAdvancedMenu} />;
      if (screen === 'menu') return <MenuScreen onSelect={selectMode} onStats={goStats} stats={stats} onBack={goHome} />;
      if (screen === 'stats') return <StatsScreen stats={stats} onBack={goMenu} onReset={resetStats} />;

      if (screen === 'kids-menu') return <KidsMenuScreen onStart={goKidsConfig} onPuzzles={goPuzzles} onBreakout={goBreakout} onCheatLives={grantCheatLives} puzzleData={puzzleData} onBack={goHome} />;
      if (screen === 'kids-config') return <KidsConfig onStart={startKidsQuiz} onBack={goKidsMenu} />;
      if (screen === 'breakout') return <BreakoutGame lives={breakoutLives} onLoseLife={loseBreakoutLife} onExit={exitBreakout} />;
      if (screen === 'kids-quiz') return <KidsQuizScreen questions={questions} onFinish={finishKidsQuiz} onMenu={goKidsMenu} />;
      if (screen === 'kids-result') return (
        <KidsResultScreen
          results={results}
          puzzleData={puzzleData}
          earnedPiece={showAnimation && earnedPiece}
          newPieceIndex={newPieceIndex}
          puzzleJustCompleted={showAnimation && puzzleJustCompleted}
          completedPuzzleIdx={completedPuzzleIdx}
          onRestart={restartKids}
          onMenu={goKidsMenu}
          onDismissAnimation={dismissAnimation}
        />
      );
      if (screen === 'puzzles') return <PuzzlesGallery puzzleData={puzzleData} onBack={goKidsMenu} onSelectPuzzle={selectPuzzle} />;

      if (screen === 'config') {
        if (mode === 'multiplication' || mode === 'division') {
          return <TablesConfig mode={mode} onStart={startQuiz} onBack={goMenu} />;
        }
        return <RangeConfig mode={mode} onStart={startQuiz} onBack={goMenu} />;
      }

      if (screen === 'quiz') {
        return <QuizScreen mode={mode} questions={questions} difficulty={difficulty} onFinish={finishQuiz} onMenu={goMenu} />;
      }

      return <ResultScreen mode={mode} results={results} difficulty={difficulty} newAchievements={newAchievements} onRestart={restart} onConfig={goConfig} onMenu={goMenu} />;
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
